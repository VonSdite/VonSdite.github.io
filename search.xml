<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[获取leetcode题目Html代码, markdown原汁原味呈现leetcode题目]]></title>
    <url>%2Fposts%2F31cb5475.html</url>
    <content type="text"><![CDATA[项目代码: https://github.com/VonSdite/GetLeetcodeQuestion前言写leetcode题解(特指用markdown写)的时候, 想把leetcode的题目信息也放入到题解中,但是又不想截图(图片占空间、而且题目可能很长, 需要分段截图),因此想着把leetcode题目的html直接拿下来, 但是直接copy html代码,又会丢失css样式, 不能很好地将题目原样呈现出来, 而且操作繁琐,所以就做了一个获取leetcode题目信息html代码的Chrome插件环境Chrome插件(仅适用Chrome内核的浏览器, 比如Chrome、360、QQ浏览器等)使用使用命令gitclone本项目1git clone https://github.com/VonSdite/GetLeetcodeQuestion.git打开Chrome浏览器的扩展程序(点击Chrome浏览器右上角设置 - 更多工具 - 扩展程序(E))点击加载已解压的扩展程序, 选择本项目即可演示完成上述操作后,以后打开leetcode的题目就会在题目旁边多了如下的按钮, 点击按钮即可将题目的html代码放入到剪切板中¶复制的html代码之后只需要ctrl+v就可以粘贴代码了, 比如上面这题Two Sum粘贴出来的代码如下123456789101112131415[Two Sum - LeetCode](https://leetcode.com/problems/two-sum/)&lt;div style="margin:1em 0;font-size:13px;"&gt;&lt;div&gt;&lt;p&gt;Given an array of integers, return &lt;strong&gt;indices&lt;/strong&gt; of the two numbers such that they add up to a specific target.&lt;/p&gt;&lt;p&gt;You may assume that each input would have &lt;strong&gt;&lt;em&gt;exactly&lt;/em&gt;&lt;/strong&gt; one solution, and you may not use the &lt;em&gt;same&lt;/em&gt; element twice.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;&lt;pre style="white-space:pre-wrap;background:#f7f9fa;padding:10px15px;color:#263238;line-height:1.6;font-size:13px;border-radius:3px;margin-top:0;margin-bottom:1em;overflow:auto;font-family:SFMono-Regular,Consolas,LiberationMono,Menlo,Courier,monospace;"&gt;Given nums = [2, 7, 11, 15], target = 9,Because nums[&lt;strong&gt;0&lt;/strong&gt;] + nums[&lt;strong&gt;1&lt;/strong&gt;] = 2 + 7 = 9,return [&lt;strong&gt;0&lt;/strong&gt;, &lt;strong&gt;1&lt;/strong&gt;].&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;markdown中的效果Two Sum - LeetCodeGiven an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.Example:Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. &nbsp;可以发现, 粘贴的代码与原来的html代码的区别:html标签的class均被替换为原来的css样式&lt;pre&gt;标签额外添加了它的css样式]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Chrome插件</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Chrome插件</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter 常用魔法命令]]></title>
    <url>%2Fposts%2Fe422ea85.html</url>
    <content type="text"><![CDATA[前言Jupyter NoteBook 是功能强大的Python交互IDE, 自带的一些常用Magic Command 可以让它变得更加得心应手。magic函数主要包含两大类，一类是**行魔法（Line magic）前缀为%，一类是单元魔法(Cell magic)**前缀为%%;%lsmagic打印当前可以用的魔法命令%matplotlib inline使用matplotlib画图时，图片嵌入在jupyter notebook里面，不以单独窗口显示%timeit %%timeit为代码执行计时%timeit 是 行魔法命令%%timeit 是 块魔法命令%%writefile后面紧接着一个file_name.py, 表示在jupyter notebook里面创建一个py文件，后面cell里面的内容为py文件内容比如123%%writefile test_peace.pyimport numpy as npprint(np.random.randint(1,5))在当前路径下会生成一个test_peace.py的文件，内容就是cell里面的内容%run后面紧接着一个相对地址的file_name.py，表示运行一个py文件比如1%run test_peace.py%pwd查找当前目录%cd更改当前目录%cp复制文件1%cp test_peace.py test_load.py%whos查看当前变量,类型，信息123456Variable Type Data/Info-------------------------------np module &lt;module 'numpy' from '/us&lt;...&gt;kages/numpy/__init__.py'&gt;plt module &lt;module 'matplotlib.pyplo&lt;...&gt;es/matplotlib/pyplot.py'&gt;x float64 -0.3048106211022167y list n=3%reset清除变量%del清除某一个变量%load加载一个文件里面的内容1%load test_peace.py魔法命令+?加?可以获取魔法命令的用法]]></content>
      <categories>
        <category>Python</category>
        <category>Jupyter</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter Lab默认快捷键与Jupyter Notebook的区别]]></title>
    <url>%2Fposts%2Fc0a62ed9.html</url>
    <content type="text"><![CDATA[前言Jupyter Notebook和Jupyter Lab还是挺像的, 但Jupyter Lab更像IDE多一点虽说Jupyter Lab包含 Jupyter Notebook, 但是Jupyter Notebook的一些快捷键在 Jupyter Lab中用不了以下均是Jupyter Notebook的快捷键, 会说明哪些在Jupyter Lab中失效了命令行模式(按 Esc 生效)按键功能F查找并且替换 Lab中失效了Ctrl-Shift-F打开命令配置 Lab中失效了, 变成了隐藏侧边栏Ctrl-Shift-P打开命令配置 Lab中失效了, 打印服务…Enter进入编辑模式P打开命令配置 Lab中失效了Alt-Enter运行代码块并且插入下面Y把代码块变成代码M把代码块变成标签R清除代码块格式1把代码块变成heading 12把代码块变成heading 23把代码块变成heading 34把代码块变成heading 45把代码块变成heading 56把代码块变成heading 6K选择上面的代码块方向键上选择上面的代码块方向键下选择下面的代码块J选择下面的代码块Shift-K扩展上面选择的代码块Shift-方向键上扩展上面选择的代码块Shift-方向键下扩展下面选择的代码块Shift-J扩展下面选择的代码块A在上面插入代码块B在下面插入代码块X剪切选择的代码块C复制选择的代码块Shift-V粘贴到上面V粘贴到下面Z撤销D,D删除选中单元格Shift-M合并选中单元格, 如果只有一个单元格被选中Ctrl-S保存并检查S保存并检查 Lab中失效了L切换行号O折叠单元格的输出 Lab中失效了Shift-O切换选定单元的输出滚动 不知道有什么用, 也失效了H显示快捷键 Lab中失效了I,I中断服务0,0重启服务(带窗口)Shift-L在所有单元格中切换行号, 并保持设置Shift-空格向上滚动空格向下滚动编辑模式(按 Enter 生效)按键功能Tab代码完成或缩进Shift-Tab工具提示 不知道有什么用Ctrl-]缩进Ctrl-[取消缩进Ctrl-A全选Ctrl-Z撤销Ctrl-/注释Ctrl-D删除整行Ctrl-U撤销Insert切换 重写标志Ctrl-Home跳到单元格起始处Ctrl-上跳到单元格起始处Ctrl-End跳到单元格最后Ctrl-下跳到单元格最后Ctrl-左跳到单词左边Ctrl-右跳到单词右边Ctrl-backspace删除前面的单词Ctrl-Delete删除后面的单词Ctrl-Y重做Ctrl-M进入命令行模式Ctrl-Shift-F打开命令配置 Lab中失效了, 变成了隐藏侧边栏Ctrl-Shift-P打开命令配置 Lab中失效了, 打印服务…Esc进入命令行模式Alt-Enter运行代码块并且插入下面Ctrl-S保存并检查方向键下光标下移方向键上光标上移]]></content>
      <categories>
        <category>Python</category>
        <category>Jupyter</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[conda 管理python包和环境]]></title>
    <url>%2Fposts%2F99747462.html</url>
    <content type="text"><![CDATA[前言Conda 是一个开源的软件包管理系统和环境管理系统, 用于安装多个版本的软件包及其依赖关系, 并可在它们之间轻松切换。Conda 是为 Python 程序创建的, 适用于 Linux, OS X 和Windows, 是目前最流行的 Python 环境管理工具管理包¶conda 安装包在终端中键入 conda install [-n env_name] package_name可以通过[-n env_name]指定要安装包的环境例如, 要安装 numpy, 请键入 conda install numpy。你还可以同时安装多个包。类似 conda install numpy scipy pandas 的命令会同时安装所有这些包。还可以通过添加版本号(例如 conda install numpy=1.10)来指定所需的包版本。Conda 还会自动为你安装依赖项。例如, scipy 依赖于 numpy, 因为它使用并需要 numpy。如果你只安装 scipy (conda install scipy), 则 conda 还会安装 numpy(如果尚未安装的话)。¶添加国内源详情见: 清华镜像 https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yes¶conda 删除包在终端中键入 conda remove [-n env_name] package_name可以通过[-n env_name]指定要删除包的环境¶conda 更新包在终端中键入 conda update package_name如果想更新环境中的所有包, 请使用 conda update --all¶conda 列出包在终端中键入 conda list¶conda 搜索包在终端中键入 conda search search_iterm管理环境¶conda 创建环境你可以使用 conda 创建环境以隔离项目。要创建环境, 请在终端中使用 conda create -n env_name [list of packages] [python=version]。创建具有特定 Python 版本的环境,请键入类似于 conda create -n py3 python=3 或 conda create -n py2 python=2 的命令,这些命令将分别安装 Python 3 和 Python 2 的最新版本。要安装特定版本(例如 Python 3.3), 请使用 conda create -n py python=3.3。在这里,-n env_name 设置环境的名称(-n 是指名称),list of packages 是要安装在环境中的包的列表, 可不设置python=version version是指python版本, 一般都指定只执行conda create -n env_name只会创建一个空的环境, 连python都没有, 运行的python是环境变量的python。需要装一个库后, 才会有python例如, 要创建名为 my_env 的环境并在其中安装 numpy, 请键入 conda create -n my_env numpy python=3.7。¶conda 进入环境创建了环境后,在 OSX/Linux 上使用 source activate my_env 进入环境在 Windows 上, 请使用 activate my_env¶conda 退出环境要离开环境,在 OSX/Linux 上使用 source deactivate在 Windows 上, 请使用 deactivate¶conda 查看环境终端键入 conda info -e 或 conda info --env¶conda 删除环境终端键入 conda remove -n env_name --all环境导出和导入¶环境导出使用 conda env export &gt; environment.yaml 将包信息保存为 YAML。命令的第一部分 conda env export 用于输出环境中的所有包的名称(包括 Python 版本)。¶环境导入要通过环境文件导入环境,使用 conda env create -f environment.yaml这会创建一个新环境, 而且它具有同样的在 environment.yaml 中列出的库。其他conda update conda # 检查更新当前condapython -version # 检查当前环境python版本]]></content>
      <categories>
        <category>Python</category>
        <category>Anaconda</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda Navigator 简介]]></title>
    <url>%2Fposts%2F13d55c5e.html</url>
    <content type="text"><![CDATA[简介¶Anaconda NavigatorAnaconda Navigator: 是Anaconda Prompt的图形界面, 提供图形化显示和鼠标操作, 可以管理、安装更新第三方包等¶Anaconda PromptAnaconda Prompt: 是一个Anaconda的终端, 类似cmd命令可以便捷操作conda环境, 可以建立不同的python版本环境如Python2和Python3¶IPythonIPython: 是一个 python 的交互式 shell, 比默认的python shell 好用得多, 支持变量自动补全(tab), 自动缩进, 支持 bash shell 命令, 内置了许多很有用的功能和函数。自动补全功能, 使用tab键, 如输入im后按tab键, 可自动补全import。进入IPython, CMD中输入ipython退出IPython, CMD中输入quit()¶使用魔法指令%%run test.py 直接运行python脚本%pwd: 显示当前工作目录。%cd: 切换工作目录。%bookmark: 工作目录书签¶使用快捷键ctrl+u 删除整行(光标在最后)ctrl+k 删除整行(光标在最前)ctrl+l 清空屏幕ctrl+c 中止运行程序ctrl+e 跳转到最后ctrl+a 跳转到第一行(与Windows热键冲突, 是全选)ctrl+r 反向搜索历史¶Jupyter NotebookJupyter Notebook: 这得从IPython3.x版本开始说起, 这是最后的大一统版本, 包括notebook、qtconsole等等, 从IPython 4.0版本开始IPython只集中精力做交互式shell, 变得轻量化; 而剩下的notebook格式, qtconsole, 和notebook web应用等都分离出来统一命名为Jupyter,至此IPython和Jupyter分家。jupyter用网页浏览器打开, 以cell为单元运行, 可用cmd命令直接打开。¶Jupyter的各种快捷键执行当前cell, 并自动跳到下一个cell: Shift Enter执行当前cell, 执行后不自动调转到下一个cell: Ctrl Enter是当前的cell进入编辑模式:Enter退出当前cell的编辑模式: Esc删除当前的cell: 双D为当前的cell加入line number: 单L将当前的cell转化为具有一级标题的maskdown: 单1将当前的cell转化为具有二级标题的maskdown: 单2将当前的cell转化为具有三级标题的maskdown: 单3为一行或者多行添加/取消注释: Crtl /撤销对某个cell的删除: z浏览器的各个Tab之间切换: Crtl PgUp和Crtl PgDn快速跳转到首个cell: Crtl Home快速跳转到最后一个cell: Crtl End¶Jupyter QtconsoleJupyter Qtconsole: 调用交互式命令台。从IPython4.0版本开始, 很多IPython子命令现在变成了Jupyter子命令, 如ipython notebook现在是jupyter noteboook。¶SpyderSpyder: 是一个使用Python语言的开放源代码跨平台科学运算IDE。Spyder可以跨平台, 也可以使用附加组件扩充, 自带交互式工具以处理数据。可以直接查看对象, 如果是多列还是彩色的, 相对来说便于分辨行列。]]></content>
      <categories>
        <category>Python</category>
        <category>Anaconda</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决hexo leancloud Too many requests 错误]]></title>
    <url>%2Fposts%2F416930d1.html</url>
    <content type="text"><![CDATA[前言LeanCloud可以统计Hexo文章的阅读次数, 但是有它的缺陷。当你的文章数目逐渐变多的时候, 使用hexo d时, 经常会出现 Too many requests的错误。原因是, 使用免费开发版Leancloud无法短时间内接受太多的请求, 所以会导致429错误。官方解释信息 - Too many requests.含义 - 超过应用的流控限制, 即超过每个应用同一时刻最多可使用的工作线程数, 或者说同一时刻最多可以同时处理的数据请求。通过 控制台 &gt; 存储 &gt; API 统计 &gt; API 性能 &gt; 总览 可以查看应用产生的请求统计数据, 如平均工作线程、平均响应时间等。使用 LeanCloud 商用版或企业版 的用户, 如有需要, 可以联系我们来调整工作线程数。原因查看源代码, node_modules\hexo-leancloud-counter-security\index.js, 发现每次进行hexo d的时候, 他对每个博文的title和url, 向leancloud发送一次查询请求, 如果发现leancloud那边儿没有该条记录的话, 那么再发送一条插入请求。原逻辑如下:12345678910111213141516171819_.forEach(urls, function (x) &#123; var query = new AV.Query('Counter'); query.equalTo('url', x.url); query.count().then(function (count) &#123; if (count === 0) &#123; var counter = new Counter(); counter.set('url', x.url); counter.set('title', x.title); counter.set('time', 0); counter.save().then(function (obj) &#123; log.info(x.title + ' is saved as: ' + obj.id); &#125;, function (error) &#123; log.error(error); &#125;); &#125; &#125;, function (error) &#123; log.error(error); &#125;);&#125;);就是说, 每一次hexo d的时候最少的查询次数等于你的博文个数。如果你的leancloud的应用的处理能力不够强大的时候, 对于这种高强度的请求, 当然会出现Too Many Requests的错误代码。我们要做的就是较少不必要的请求咯。本地记录一个title和url的json数组, 每次查询这个数组, 看看哪些是真正的需要查询的, 然后再去查询leancloud。其实可以这样理解, 这个本地的数组存储就是leancloud的远程数据库表。因为筛除了一些记录, 所以每次hexo d时的请求数量仅仅是相比上一次hexo d时候的增量。修改代码修改node_modules\hexo-leancloud-counter-security\index.js这个文件, 修改处代码均有注释, 往下翻就可以看到了展开代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277'use strict';var _regenerator = require('babel-runtime/regenerator');var _regenerator2 = _interopRequireDefault(_regenerator);var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);var _stringify = require('babel-runtime/core-js/json/stringify');var _stringify2 = _interopRequireDefault(_stringify);var sync = function () &#123; var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() &#123; var log, config, APP_ID, APP_KEY, publicDir, UrlsFile, urls, currentUser, userName, passWord, Counter; return _regenerator2.default.wrap(function _callee$(_context) &#123; while (1) &#123; switch (_context.prev = _context.next) &#123; case 0: log = this.log; config = this.config; if (!config.leancloud_counter_security.enable_sync) &#123; _context.next = 19; break; &#125; APP_ID = config.leancloud_counter_security.app_id; APP_KEY = config.leancloud_counter_security.app_key; publicDir = this.public_dir; UrlsFile = pathFn.join(publicDir, 'leancloud_counter_security_urls.json'); urls = JSON.parse(fs.readFileSync(UrlsFile, 'utf8')); AV.init(&#123; appId: APP_ID, appKey: APP_KEY &#125;); currentUser = AV.User.current(); if (currentUser) &#123; _context.next = 16; break; &#125; userName = config.leancloud_counter_security.username; passWord = config.leancloud_counter_security.password; if (!userName) &#123; userName = readlineSync.question('Enter your username: '); passWord = readlineSync.question('Enter your password: ', &#123; hideEchoBack: true &#125;); &#125; else if (!passWord) &#123; passWord = readlineSync.question('Enter your password: ', &#123; hideEchoBack: true &#125;); &#125; _context.next = 16; return AV.User.logIn(userName, passWord).then(function (loginedUser) &#123; log.info('Logined as: ' + loginedUser.getUsername()); &#125;, function (error) &#123; log.error(error); &#125;); case 16: log.info('Now syncing your posts list to leancloud counter...'); Counter = AV.Object.extend('Counter'); //----add---- urls.sort(cmp); var memoFile = pathFn.join(publicDir, "leancloud_memo.json"); if(!fs.existsSync(memoFile))&#123; fs.writeFileSync(memoFile, "[\n]"); &#125; var memoData = fs.readFileSync(memoFile, "utf-8").split("\n"); var memoIdx = 1; var newData = []; var cnt = 0; var limit = 0; var env = this; //----end---- _.forEach(urls, function (x) &#123; //----add---- var y = &#123;&#125;; y.title = ""; y.url = ""; var flag = false; while(true)&#123; if(memoData[memoIdx] == ']') break; y = JSON.parse(memoData[memoIdx].substring(0, memoData[memoIdx].length-1)); if(y.url &gt; x.url) break; if(y.url == x.url &amp;&amp; y.title == x.title)&#123; flag = true; break; &#125; memoIdx++; &#125; if(!flag) &#123; log.info("Dealing with record of " + x.title); limit++; //----end---- var query = new AV.Query('Counter'); query.equalTo('url', x.url); query.count().then(function (count) &#123; if (count === 0) &#123; var counter = new Counter(); counter.set('url', x.url); counter.set('title', x.title); counter.set('time', 0); counter.save().then(function (obj) &#123; log.info(x.title + ' is saved as: ' + obj.id); //----add---- newData.push(x); cnt++; postOperation(env, cnt, limit, newData, memoData); //----end---- &#125;, function (error) &#123; log.error(error); //----add---- cnt++; postOperation(env, cnt, limit, newData, memoData); //----end---- &#125;); &#125; //----add---- else&#123; newData.push(x); cnt++; postOperation(env, cnt, limit, newData, memoData); &#125; //----end---- &#125;, function (error) &#123; log.error(error); //----add---- cnt++; postOperation(env, cnt, limit, newData, memoData); //----end---- &#125;); //----add---- &#125; //----end---- &#125;); case 19: case 'end': return _context.stop(); &#125; &#125; &#125;, _callee, this); &#125;)); return function sync() &#123; return _ref.apply(this, arguments); &#125;;&#125;();function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;var AV = require('leancloud-storage');var _ = require('lodash');var readlineSync = require('readline-sync');var packageInfo = require('./package.json');var pathFn = require('path');var fs = require('fs');function generate_post_list(locals) &#123; var config = this.config; if (config.leancloud_counter_security.enable_sync) &#123; var urlsPath = 'leancloud_counter_security_urls.json'; var urls = [].concat(locals.posts.toArray()).filter(function (x) &#123; return x.published; &#125;).map(function (x) &#123; return &#123; title: x.title, url: config.root + x.path &#125;; &#125;); return &#123; path: urlsPath, data: (0, _stringify2.default)(urls) &#125;; &#125;&#125;hexo.extend.generator.register('leancloud_counter_security_generator', generate_post_list);hexo.extend.deployer.register('leancloud_counter_security_sync', sync);var commandOptions = &#123; desc: packageInfo.description, usage: ' &lt;argument&gt;', 'arguments': [&#123; 'name': 'register | r &lt;username&gt; &lt;password&gt;', 'desc': 'Register a new user.' &#125;]&#125;;function commandFunc(args) &#123; var log = this.log; var config = this.config; if (args._.length !== 3) &#123; log.error('Too Few or Many Arguments.'); &#125; else if (args._[0] === 'register' || args._[0] === 'r') &#123; var APP_ID = config.leancloud_counter_security.app_id; var APP_KEY = config.leancloud_counter_security.app_key; AV.init(&#123; appId: APP_ID, appKey: APP_KEY &#125;); var user = new AV.User(); user.setUsername(String(args._[1])); user.setPassword(String(args._[2])); user.signUp().then(function (loginedUser) &#123; log.info(loginedUser.getUsername() + ' is successfully signed up'); &#125;, function (error) &#123; log.error(error); &#125;); &#125; else &#123; log.error('Unknown Command.'); &#125;&#125;hexo.extend.console.register('lc-counter', 'hexo-leancloud-counter-security', commandOptions, commandFunc);//----add----function cmp(x, y)&#123; if(x.url &lt; y.url) return -1; else if(x.url == y.url) return 0; else return 1;&#125;var postOperation = function (env, cnt, limit, newData, memoData)&#123; if(cnt == limit)&#123; var log = env.log; newData.sort(cmp); var sourceDir = env.source_dir; var publicDir = env.public_dir; var memoFile = pathFn.join(sourceDir, "leancloud_memo.json"); fs.writeFileSync(memoFile, "[\n"); var memoIdx = 1; for(var i = 0; newData[i]; i++)&#123; while(true)&#123; if(memoData[memoIdx] == ']') break; var y = JSON.parse(memoData[memoIdx].substring(0, memoData[memoIdx].length-1)); if(y.url &gt; newData[i].url) break; fs.writeFileSync(memoFile, memoData[memoIdx] + "\n", &#123;'flag':'a'&#125;); memoIdx++; &#125; fs.writeFileSync(memoFile, "&#123;\"title\":\"" + newData[i].title + "\",\"url\":\"" + newData[i].url + "\"&#125;,\n", &#123;'flag':'a'&#125;); &#125; while(memoData[memoIdx] != ']')&#123; fs.writeFileSync(memoFile, memoData[memoIdx] + "\n", &#123;'flag':'a'&#125;); memoIdx++; &#125; fs.writeFileSync(memoFile, memoData[memoIdx], &#123;'flag':'a'&#125;); var srcFile = pathFn.join(sourceDir, "leancloud_memo.json"); var destFile = pathFn.join(publicDir, "leancloud_memo.json"); var readStream = fs.createReadStream(srcFile); var writeStream = fs.createWriteStream(destFile); readStream.pipe(writeStream); console.log("leancloud_memo.json successfully updated."); &#125;&#125;修改完后, 还需要打开博客配置文件_config.yml找到skip_render:这一项，然后加上leancloud_memo.json。12skip_render: - leancloud_memo.json]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>Leancloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K-Means 算法实现, 动态显示变化]]></title>
    <url>%2Fposts%2Fb62ef61c.html</url>
    <content type="text"><![CDATA[项目介绍源代码: https://github.com/VonSdite/K-Means使用前记得先安装相关的包1pip install -r requirement.txt¶以本项目为例先运行dataClean.py程序, 对数据iris.data做处理, 得到iris.csv以及真实的分类图iris.data是鸢尾花数据集, 包含3个不同品种的鸢尾花(Setosa, Versicolour, and Virginica)数据, 以及花瓣和萼片的长度、宽度。 数据有150行4列, 150行指150朵花, 4列分别是Sepal Length(萼片长度), Sepal Width(萼片宽度), Petal Length(花瓣长度) and Petal Width(花瓣宽度)运行main.py点击 打开-open file, 打开csv文件(也只能打开csv文件)注意csv文件的要求:要带有表头数据是两列数值数据, 所以需要先处理数据数据格式类似如下1234x,y1,12,34,5打开后, 会先绘制出数据的散点图输入分类个数k-点击分类, 分类过程如下分类过程中, 左下角状态栏会显示当前的状态¶分类结果比较分析因为数据只用到了萼片的宽度和长度, 只做了二维数据的k-means, 所以对于区分1类和2类花朵的效果还没达到完全区分的效果, 但是已经能万全区分0类花朵了提升方面, 提升维度, 把花瓣的宽度和长度也考虑进去, 可能可以更好的区分K-Means介绍¶概述K-means算法是集简单和经典于一身的基于距离的聚类算法采用距离作为相似性的评价指标, 即认为两个对象的距离越近, 其相似度就越大。该算法认为类簇是由距离靠近的对象组成的, 因此把得到紧凑且独立的簇作为最终目标。¶核心思想通过迭代寻找k个类簇的一种划分方案, 使得用这k个类簇的均值来代表相应各类样本时所得的总体误差最小。k个聚类具有以下特点：各聚类本身尽可能的紧凑, 而各聚类之间尽可能的分开。k-means算法的基础是最小误差平方和准则,其代价函数是： 式中, μc(i)表示第i个聚类的均值。各类簇内的样本越相似, 其与该类均值间的误差平方越小, 对所有类所得到的误差平方求和, 即可验证分为k类时, 各聚类是否是最优的。上式的代价函数无法用解析的方法最小化, 只能有迭代的方法。¶算法实现步骤k-means算法是将样本聚类成 k个簇(cluster), 其中k是用户给定的, 其求解过程非常直观简单, 具体算法描述如下：随机选取 k个聚类质心点重复下面过程直到收敛 {对于每一个样例 i, 计算其应该属于的类：对于每一个类 j, 重新计算该类的质心：}其伪代码如下：12345678910111213创建k个点作为初始的质心点(随机选择)当任意一个点的簇分配结果发生改变时 对数据集中的每一个数据点 对每一个质心 计算质心与数据点的距离 将数据点分配到距离最近的簇 对每一个簇, 计算簇中所有点的均值, 并将均值作为质心¶K-means算法补充K-means算法的缺点及改进方法(1)k值的选择是用户指定的,不同的k得到的结果会有挺大的不同,如下图所示,左边是k=3的结果,这个就太稀疏了,蓝色的那个簇其实是可以再划分成两个簇的。而右图是k=5的结果,可以看到红色菱形和蓝色菱形这两个簇应该是可以合并成一个簇的：改进：对k的选择可以先用一些算法分析数据的分布,如重心和密度等,然后选择合适的k(2)对k个初始质心的选择比较敏感,容易陷入局部最小值。例如,我们上面的算法运行的时候,有可能会得到不同的结果,如下面这两种情况。K-means也是收敛了,只是收敛到了局部最小值：改进：有人提出了另一个成为二分k均值(bisecting k-means)算法,它对初始的k个质心的选择就不太敏感(3)存在局限性,如下面这种非球状的数据分布就搞不定了：(4)数据集比较大的时候,收敛会比较慢。]]></content>
      <categories>
        <category>Python</category>
        <category>KMeans</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>KMeans</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vi/vim 字符出现次数统计]]></title>
    <url>%2Fposts%2F205709c1.html</url>
    <content type="text"><![CDATA[Vi/Vim统计字符出现次数将被统计的文本内容如下1234 network. 1network net work Networked NETWORK network 1network net work Networked NETWORKnetworkednetwork network,hello worldk¶全词匹配只统计&quot;network&quot;这个单词出现的次数vi进入ex模式, 键入如下的命令1:%s/\&lt;network\&gt;//gn由图可知, 共匹配到4次, 而且我们知道单词network后面跟 &quot;.&quot; &quot;,&quot;, 它依旧是 network单词, 均被匹配到了解释% 指明操作区间, **%**表示全文本; 可以使用1,$或者行区间代替n 统计字符的个数, 替换操作不会被执行g 所有满足匹配的字符&quot;\&gt;&quot; 是一个特殊的记号, 表示只匹配单词末尾。类似地, &quot;&lt;&quot; 只匹配单词的开头。¶字符串匹配统计&quot;network&quot;这个字符串出现的次数vi进入ex模式, 键入如下的命令1:%s/network//gn由图可知, 共匹配到7次。字符串匹配, 只要有&quot;network&quot;这个字符串出现, 则就算一次匹配了。]]></content>
      <categories>
        <category>Linux</category>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[makefile 介绍与编写(四) 伪目标]]></title>
    <url>%2Fposts%2Fa08b2a98.html</url>
    <content type="text"><![CDATA[前言摘录于 《跟我一起写makefile》本文主要开始介绍makefile的伪目标。伪目标最早先的一个例子中, 我们提到过一个&quot;clean&quot;的目标, 这是一个&quot;伪目标&quot;,12clean: rm *.o temp正像我们前面例子中的&quot;clean&quot;一样, 即然我们生成了许多文件编译文件, 我们也应该提供一个清除它们的&quot;目标&quot;以备完整地重编译而用。 (以&quot;make clean&quot;来使用该目标)因为, 我们并不生成&quot;clean&quot;这个文件。&quot;伪目标&quot;并不是一个文件, 只是一个标签。由于&quot;伪目标&quot;不是文件, 所以 make 无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个&quot;目标&quot;才能让其生效。当然, &quot;伪目标&quot;的取名不能和文件名重名, 不然其就失去了&quot;伪目标&quot;的意义了。当然, 为了避免和文件重名的这种情况, 我们可以使用一个特殊的标记&quot;.PHONY&quot;来显示地指明一个目标是&quot;伪目标&quot;, 向 make 说明, 不管是否有这个文件, 这个目标就是&quot;伪目标&quot;。1.PHONY : clean只要有这个声明, 不管是否有&quot;clean&quot;文件, 要运行&quot;clean&quot;这个目标, 只有&quot;make clean&quot;这样。于是整个过程可以这样写:123.PHONY: cleanclean:rm *.o temp伪目标一般没有依赖的文件, 但是, 我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为&quot;默认目标&quot;, 只要将其放在第一个。¶作为默认目标示例一个示例就是, 如果你的 Makefile 需要一口气生成若干个可执行文件, 但你只想简单地敲一个 make 完事, 并且, 所有的目标文件都写在一个 Makefile 中, 那么你可以使用&quot;伪目标&quot;这个特性:12345678all : prog1 prog2 prog3.PHONY : allprog1 : prog1.o utils.occ -o prog1 prog1.o utils.oprog2 : prog2.occ -o prog2 prog2.oprog3 : prog3.o sort.o utils.occ -o prog3 prog3.o sort.o utils.o我们知道, Makefile 中的第一个目标会被作为其默认目标。我们声明了一个&quot;all&quot;的伪目标, 其依赖于其它三个目标。由于伪目标的特性是, 总是被执行的, 所以, 其它三个目标的规则总是会被运行, 也就达到了我们一口气生成多个目标的目的。&quot;.PHONY : all&quot;声明了&quot;all&quot;这个目标为&quot;伪目标&quot;。¶作为依赖 示例从上面的例子我们可以看出, 目标也可以成为依赖。所以, 伪目标同样也可成为依赖。看下面的例子:1234567.PHONY: cleanall cleanobj cleandiffcleanall : cleanobj cleandiffrm programcleanobj :rm *.ocleandiff :rm *.diff&quot;cleanobj&quot;和&quot;cleandiff&quot;这两个**伪目标有点像&quot;子程序&quot;**的意思。我们可以输入&quot;make cleanall&quot;、&quot;make cleanobj&quot;、&quot;make cleandiff&quot;命令来达到清除不同种类文件的目的。]]></content>
      <categories>
        <category>C/C++</category>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[makefile 介绍与编写(三) make 文件遍寻]]></title>
    <url>%2Fposts%2F1faeaacd.html</url>
    <content type="text"><![CDATA[前言摘录于 《跟我一起写makefile》本文主要开始介绍makefile的文件遍寻。文件遍寻在一些大的工程中, 有大量的源文件, 我们通常的做法是把这许多的源文件分类, 并存放在不同的目录中。所以, 当 make 需要去找寻文件的依赖关系时, 你可以在文件前加上路径, 但最好的方法是把一个路径告诉 make, 让 make 在自动去找。¶VPATHMakefile 文件中的特殊变量&quot;VPATH&quot;可以指定源文件的目录所在。如果没有指明这个变量, make 只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量, 那么, make就会在当 当前目录找不到的情况下, 到所指定的目录中去找寻文件了。1VPATH = src:../headers上面的的定义指定两个目录, &quot;src&quot;和&quot;…/headers&quot;,make 会按照这个顺序进行搜索。目录由&quot;冒号&quot;分隔。(当然, 当前目录永远是最高优先搜索的地方)¶vpath另一个设置文件搜索路径的方法是使用 make 的&quot;vpath&quot;关键字(注意, 它是全小写的), 这不是变量, 这是一个 make 的关键字, 这和上面提到的那个 VPATH 变量很类似, 但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。¶使用方法使用方法有三种:vpath &lt;pattern&gt; &lt;directories&gt;为符合模式的文件指定搜索目录vpath &lt;pattern&gt;清除符合模式的文件的搜索目录。vpath清除所有已被设置好了的文件搜索目录。vapth 使用方法中的需要包含&quot;%&quot;字符。&quot;%&quot;的意思是匹配零或若干字符。例如, &quot;%.h&quot;表示所有以&quot;.h&quot;结尾的文件。指定了要搜索的文件集, 而则指定了的文件集的搜索的目录。例如:1vpath %.h ../headers该语句表示, 要求 make 在&quot;…/headers&quot;目录下搜索所有以&quot;.h&quot;结尾的文件。(如果某文件在当前目录没有找到的话)我们可以连续地使用 vpath 语句, 以指定不同搜索策略。如果连续的 vpath 语句中出现了相同的, 或是被重复了的, 那么, make 会按照 vpath 语句的先后顺序来执行搜索。如:123vpath %.c foovpath % blishvpath %.c bar其表示&quot;.c&quot;结尾的文件, 先在&quot;foo&quot;目录, 然后是&quot;blish&quot;, 最后是&quot;bar&quot;目录。12vpath %.c foo:barvpath % blish而上面的语句则表示&quot;.c&quot;结尾的文件, 先在&quot;foo&quot;目录, 然后是&quot;bar&quot;目录, 最后才是&quot;blish&quot;目录]]></content>
      <categories>
        <category>C/C++</category>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[makefile 介绍与编写(二) 概述]]></title>
    <url>%2Fposts%2F41973083.html</url>
    <content type="text"><![CDATA[前言摘录于 《跟我一起写makefile》本文主要开始介绍makefile的详细细节。Makefile组成部分¶显式规则显式规则说明了, 如何生成一个或多的的目标文件。这是由 Makefile 的书写者明显指出, 要生成的文件, 文件的依赖文件, 生成的命令¶隐晦规则由于 make 有自动推导的功能, 所以隐晦的规则可以让我们比较粗糙地简略地书写 Makefile, 这是由 make 所支持的。¶变量定义在 Makefile 中我们要定义一系列的变量, 变量一般都是字符串, 当 Makefile 被执行时, 其中的变量都会被扩展到相应的引用位置上¶文件指示其包括了三个部分,一个是在一个 Makefile 中引用另一个 Makefile, 就像 C 语言中的include 一样;另一个是指根据某些情况指定 Makefile 中的有效部分, 就像 C 语言中的预编译#if 一样;还有就是定义一个多行的命令¶注释Makefile 中只有行注释, 和 UNIX 的 Shell 脚本一样, 其注释是用&quot;#&quot;字符。如果你要在你的 Makefile 中使用&quot;#&quot;字符, 可以用转义字符\框起来makefile的文件名默认的情况下, make 命令会在当前目录下按顺序找寻文件名为&quot;GNUmakefile&quot;、&quot;makefile&quot;、&quot;Makefile&quot;的文件, 找到了解释这个文件。在这三个文件名中, 最好使用&quot;Makefile&quot;这个文件名, 因为, 这个文件名第一个字符为大写, 这样有一种显目的感觉。最好不要用&quot;GNUmakefile&quot;, 这个文件是 GNU 的 make 识别的。有另外一些 make 只对全小写的&quot;makefile&quot;文件名敏感, 但是基本上来说, 大多数的 make 都支持&quot;makefile&quot;和&quot;Makefile&quot;这两种默认文件名。当然, 你可以使用别的文件名来命名Makefile, 比如: &quot;Make.Linux&quot; , &quot;Make.Solaris&quot;, &quot;Make.AIX&quot;等, 如果要指定特定的 Makefile, 你可以使用 make 的&quot;-f&quot;或&quot;--file&quot;参数, 如: make -f Make.Linux 或 make --file Make.AIX。include其他makefile在 Makefile 使用 include 关键字可以把别的 Makefile 包含进来, 被包含的文件会原模原样的放在当前文件的包含位置。include 的语法是:1include &lt;filename&gt;filename 可以是当前操作系统 Shell 的文件模式(可以保含路径和通配符)在include前面可以有一些空字符, 但是绝不能是[Tab]键开始。include 和可以用一个或多个空格隔开。¶举个例子举个例子, 你有这样几个 Makefile: a.mk、b.mk、c.mk, 还有一个文件叫foo.make。有一个变量$(bar), 其包含了 e.mk 和 f.mk, 那么, 下面的语句:1include foo.make *.mk $(bar)等价于:1include foo.make a.mk b.mk c.mk e.mk f.mkmake命令开始时, 会找寻 include 所指出的其它 Makefile, 并把其内容安置在当前的位。如果文件都没有指定绝对路径或是相对路径的话, make 会在当前目录下首先寻找, 如果当前目录下没有找到, 那么, make 还会在下面的几个目录下找:如果 make 执行时, 有&quot;-I&quot;或&quot;--include-dir&quot;参数, 那么 make 就会在这个参数所指定的目录下去寻找。如果目录/include(一般是/usr/local/include)存在的话, make 也会去找。如果有文件没有找到的话, make 会生成一条警告信息, 但不会马上出现致命错误。它会继续载入其它的文件, 一旦完成 makefile 的读取, make 会再重试这些没有找到, 或是不能读取的文件, 如果还是不行, make 才会出现一条致命信息。如果你想让 make不理那些无法读取的文件, 而继续执行, 你可以在 include 前加一个减号&quot;-&quot;。如1-include &lt;filename&gt;其表示, 无论 include 过程中出现什么错误, 都不要报错继续执行。和其它版本 make 兼容的相关命令是 sinclude, 其作用和 include是一样的。不推荐使用的MAKEFILES环境变量如果你的当前环境中定义了环境变量 MAKEFILES, 那么, make 会把这个变量中的值做一个类似于 include 的动作。这个变量中的值是其它的 Makefile, 用空格分隔。只是, 它和 include不同的是, 从这个环境变中引入的 Makefile 的&quot;目标&quot;不会起作用, 如果环境变量中定义的文件发现错误, make 也会不理。但是在这里还是建议不要使用这个环境变量, 因为只要这个变量一被定义, 那么当你使用 make 时, 所有的 Makefile 都会受到它的影响, 这绝不是你想看到的。在这里提这个事, 只是为了告诉大家, 也许有时候你的 Makefile 出现了怪事, 那么你可以看看当前环境中有没有定义这个变量(推荐)make的工作方式GNU 的 make 工作时的执行步骤入下:读入所有的 Makefile。读入被 include 的其它 Makefile。初始化文件中的变量。推导隐晦规则, 并分析所有规则。为所有的目标文件创建依赖关系链。根据依赖关系, 决定哪些目标要重新生成。执行生成命令。1-5 步为第一个阶段, 6-7 为第二个阶段。第一个阶段中, 如果定义的变量被使用了, 那么, make 会把其展开在使用的位置。但 make 并不会完全马上展开, make 使用的是拖延战术, 如果变量出现在依赖关系的规则中, 那么仅当这条依赖被决定要使用了, 变量才会在其内部展开。]]></content>
      <categories>
        <category>C/C++</category>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[makefile 介绍与编写(一) 介绍及使用]]></title>
    <url>%2Fposts%2Fc6ce89df.html</url>
    <content type="text"><![CDATA[前言摘录于 《跟我一起写makefile》一个工程中的源文件一般不计其数, 其按类型、功能、模块分别放在若干个目录中, makefile 定义了一系列的规则来指定, 哪些文件需要先编译, 哪些文件需要后编译, 哪些文件需要重新编译, 甚至于进行更复杂的功能操作。因为makefile 就像一个 Shell 脚本一样, 其中也可以执行操作系统的命令。 makefile 带来的好处就是——&quot;自动化编译&quot;, 一旦写好, 只需要一个 make 命令, 整个工程完全自动编译, 极大的提高了软件开发的效率。make 是一个命令工具, 是一个解释 makefile 中指令的命令工具, 一般来说, 大多数的 IDE 都有这个命令, 比如：Delphi 的 make, Visual C++的 nmake, Linux 下 GNU 的 make。可见, makefile 都成为了一种在工程方面的编译方法关于程序的编译与链接一般来说, 无论是 C、C++、还是 pas, 首先要把源文件编译成中间代码文件, 在 Windows 下也就是 .obj 文件, UNIX 下是 .o 文件, 即 Object File, 这个动作叫做编译(compile)。然后再把大量的 Object File 合成执行文件, 这个动作叫作链接(link)。 编译时, 编译器需要的是语法的正确, 函数与变量的声明的正确。对于函数与变量的声明, 通常是你需要告诉编译器头文件的所在位置(头文件中应该只是声明, 而定义应该放在 C/C++文件中), 只要所有的语法正确, 编译器就可以编译出中间目标文件。一般来说, 每个源文件都应该对应于一个中间目标文件(O 文件或是 OBJ 文件)。链接时, 主要是链接函数和全局变量, 所以, 我们可以使用这些中间目标文件(O 文件或是 OBJ文件)来链接我们的应用程序。链接器并不管函数所在的源文件, 只管函数的中间目标文件(Object File), .在大多数时候, 由于源文件太多, 编译生成的中间目标文件太多, 而在链接时需要明显地指出中间目标文件名, 这对于编译很不方便, 所以, 我们要给中间目标文件打个包, 在 Windows 下这种包叫&quot;库文件&quot;(Library FileMakefile), 也就是 .lib 文件, 在 UNIX下, 是 Archive File, 也就是 .a 文件。总结一下, 源文件首先会生成中间目标文件, 再由中间目标文件生成执行文件。在编译时, 编译器只检测程序语法, 和函数、变量是否被声明。如果函数未被声明, 编译器会给出一个警告, 但可以生成 Object File。而在链接程序时, 链接器会在所有的 Object File 中找寻函数的实现, 如果找不到, 那到就会报链接错误码(Linker Error), 在 VC 下, 这种错误一般是：Link 2001 错误, 意思说是说, 链接器未能找到函数的实现。你需要指定函数的Object File.makefile的规则12target: prerequisites command或者1target: prerequisites: commandcommand与target、prerequisites如果不在同一行, 一定要以**[Tab]**键开头target是一个目标文件, 可以是 Object File, 可以是 可执行文件, 也可以是一个标签(即伪目标)。prerequisites时候target目标文件所依赖的文件, 比如说一段代码a.c、a.h, 它生成的可执行程序为a.out, 那么target就为 a.out, 它所依赖的文件prerequisites为 a.c a.h。command 即make所需要执行的命令(任意的shell命令)这是一个文件的依赖关系, 也就是说, target 这一个或多个的目标文件依赖于 prerequisites 中的文件, 其生成规则定义在 command 中。说白一点就是说, prerequisites中如果有一个以上的文件比 target 文件要新的话(意思就是说只要依赖文件中有一个文件的最近修改时间比target的最近修改时间更加新), command 所定义的命令就会被执行。这就是 Makefile 的规则, 也是 Makefile 中最核心的内容。示例假设我们的工程有 8 个 C 文件, 和 3 个头文件, 我们要写一个 Makefile 来告诉 make 命令如何编译和链接这几个文件。我们的规则是：如果这个工程没有编译过, 那么我们的所有 C 文件都要编译并被链接。如果这个工程的某几个 C 文件被修改, 那么我们只编译被修改的 C 文件, 并链接目标程序。如果这个工程的头文件被改变了, 那么我们需要编译引用了这几个头文件的 C 文件, 并链接目标程序现在我们简单地makefile版本如下:123456789101112131415161718192021222324edit : main.o kbd.o command.o display.o \insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.omain.o : main.c defs.h cc -c main.ckbd.o : kbd.c defs.h command.h cc -c kbd.ccommand.o : command.c defs.h command.h cc -c command.cdisplay.o : display.c defs.h buffer.h cc -c display.cinsert.o : insert.c defs.h buffer.h cc -c insert.csearch.o : search.c defs.h buffer.h cc -c search.cfiles.o : files.c defs.h buffer.h command.h cc -c files.cutils.o : utils.c defs.h cc -c utils.cclean : rm edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o反斜杠(\)是换行符的意思。这样比较便于 Makefile 的易读。我们可以把这个内容保存在文件为&quot;Makefile&quot;或&quot;makefile&quot;的文件中,然后在该目录下直接输入命令&quot;make&quot;就可以生成执行文件 edit。如果要删除执行文件和所有的中间目标文件, 那么, 只要简单地执行一下&quot;make clean&quot;就可以了在这个 makefile 中, 目标文件(target)包含：执行文件 edit 和中间目标文件(*.o); 依赖文件(prerequisites)就是冒号后面的那些 .c 文件和 .h 文件。每一个 .o 文件都有一组依赖文件, 而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的, 换言之, 目标文件是哪些文件更新的。在定义好依赖关系后, 后续的那一行定义了如何生成目标文件的操作系统命令, 一定要以一个 Tab 键作为开头。记住, make 并不管命令是怎么工作的, 它只管执行所定义的命令。make 会比较 targets 文件和 prerequisites 文件的修改日期, 如果 prerequisites 文件的日期要比 targets 文件的日期要新, 或者 target 不存在的话, 那么, make 就会执行后续定义的命令。这里要说明一点的是, clean 不是一个文件, 它只不过是一个动作名字, 有点像 C 语言中的 lable 一样, 其冒号后什么也没有, 那么, make 就不会自动去找文件的依赖性, 也就不会自动执行其后所定义的命令。要执行其后的命令, 就要在 make 命令后明显得指出这个lable 的名字。这样的方法非常有用, 我们可以在一个 makefile 中定义不用的编译或是和编译无关的命令, 比如程序的打包, 程序的备份, 等等(推荐)make命令工作原理在默认的方式下, 也就是我们只输入 make 命令。那么,make 会在当前目录下找名字叫&quot;Makefile&quot;或&quot;makefile&quot;的文件。如果找到, 它会找文件中的第一个目标文件(target), 在上面的例子中, 他会找到&quot;edit&quot;这个文件, 并把这个文件作为最终的目标文件。如果 edit 文件不存在, 或是 edit 所依赖的后面的 .o 文件的文件修改时间要比 edit这个文件新, 那么, 他就会执行后面所定义的命令来生成 edit 这个文件。如果 edit 所依赖的.o 文件不存在, 那么 make 会在当前文件中找目标为.o 文件的依赖性, 如果找到则再根据那一个规则生成.o 文件。只要**.c文件和 .h文件是存在的**, make 就会生成 .o 文件, 然后再用 .o 文件生成 make 的终极任务, 也就是执行文件 edit 了。以上就是make的依赖性, make会一层一层去找依赖关系, 直到最终编译出第一个目标文件。在找寻的过程中, 如果出现错误, 比如最后被依赖的文件找不到, 那么make就会直接退出, 并报错, 而对于所定义的命令的错误, 或是编译不成功, make 根本不理, make 只管文件的依赖性, 即, 如果在我找了依赖关系之后, 冒号后面的文件还是不在, 那么对不起, 我就不工作啦。通过上述分析, 我们知道, 像 clean 这种伪目标, 没有被第一个目标文件直接或间接关联, 那么它后面所定义的命令将不会被自动执行, 不过, 我们可以显示要 make 执行。即命令——&quot;make clean&quot;, 以此来清除所有的目标文件, 以便重编译。¶举个例子于是在我们编程中, 如果这个工程已被编译过了,当我们修改了其中一个源文件, 比如file.c, 那么根据我们的依赖性, 我们的目标 file.o 会被重编译(也就是在这个依性关系后面所定义的命令), 于是 file.o 的文件也是最新的啦, 于是 file.o 的文件修改时间要比edit要新, 所以 edit 也会被重新链接了。如果我们改变了&quot;command.h&quot;, 那么, kdb.o、command.o 和 files.o 都会被重编译, 并且, edit 会被重链接。(推荐)makefile使用变量我们来看看 edit的生成规则1234edit : main.o kbd.o command.o display.o \insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o可以看到.o文件的字符串被重复写了两次, 当我们后续修改依赖文件的时候, 就要修改2次(加上clean, 就3次了); 虽说只要修改2次, 但多个地方要修改时, 就十分不方便, 不够灵活, 容易出错。所以, 为了 makefile 的易维护, 在 makefile 中我们可以使用变量。比如, 我们声明一个变量, 叫 objects, OBJECTS, objs, OBJS, obj, 或是 OBJ, 只要能够表示 obj 文件就行了。我们在 makefile 一开始就这样定义:12objects = main.o kbd.o command.o display.o \ insert.o search.o files.o utils.o于是, 我们就可以很方便地在我们的 makefile 中以&quot;$(objects)&quot;的方式来使用这个变量了, 于是我们的改良版 makefile 就变成下面这个样子:1234567891011121314151617181920212223objects = main.o kbd.o command.o display.o \ insert.o search.o files.o utils.oedit : $(objects) cc -o edit $(objects)main.o : main.c defs.h cc -c main.ckbd.o : kbd.c defs.h command.h cc -c kbd.ccommand.o : command.c defs.h command.h cc -c command.cdisplay.o : display.c defs.h buffer.h cc -c display.cinsert.o : insert.c defs.h buffer.h cc -c insert.csearch.o : search.c defs.h buffer.h cc -c search.cfiles.o : files.c defs.h buffer.h command.h cc -c files.cutils.o : utils.c defs.h cc -c utils.cclean : rm edit $(objects)之后只要有新的.o文件, 或者修改、删除某个.o文件, 就只需要修改objects这个变量就行了。(推荐)make 自动推导对于.o文件, make可以把它对应的.c文件放到依赖文件prerequisites中, 并自动推导出cc -c example.c这条命令。于是, 更简单的makefile版本如下:1234567891011121314151617objects = main.o kbd.o command.o display.o \ insert.o search.o files.o utils.oedit : $(objects) cc -o edit $(objects)main.o : defs.hkbd.o : defs.h command.hcommand.o : defs.h command.hdisplay.o : defs.h buffer.hinsert.o : defs.h buffer.hsearch.o : defs.h buffer.hfiles.o : defs.h buffer.h command.hutils.o : defs.h.PHONY : cleanclean : rm edit $(objects)这种方法, 也就是 make 的隐晦规则。上面文件内容中, &quot;.PHONY&quot;表示, clean是个伪目标文件。关于命令出错每当命令运行完后, make会检测每个命令的返回码,如果命令返回成功, 那么make会执行下一条命令, 当前规则中所有的命令成功返回后, 这个规则就算是成功完成了如果一个规则中的某个命令出错了(命令退出码非零), 那么make就会终止执行当前规则, 这将有可能终止所有规则的执行。但是有些时候, 命令的出错并不表示就是错误的。例如mkdir命令, 我们一定需要建立一个目录, 如果目录不存在, 那么mkdir就成功执行, 万事大吉;如果目录存在, 那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录, 于是我们就不希望mkdir出错而终止规则的运行。¶忽略命令的错误¶局部方法为了做到这一点, 忽略命令的出错, 我们可以在Makefile的命令行前加一个减号&quot;-&quot;(在Tab键之后), 标记为不管命令出不出错都认为是成功的。如：12clean: -rm -f *.o¶全局方法一个全局的办法是, 给make加上**-i或是--ignore-errors参数**, 那么, Makefile中所有命令都会忽略错误。而如果一个规则是以&quot;.IGNORE&quot;作为目标的, 那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法, 你可以根据你的不同喜欢设置。还有一个要提一下的make的参数的是&quot;-k&quot;或是&quot;--keep-going&quot;, 参数的意思是, 如果某规则中的命令出错了, 那么就终止该规则的执行, 但继续执行其它规则。]]></content>
      <categories>
        <category>C/C++</category>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用gdb调试C/C++程序]]></title>
    <url>%2Fposts%2F898073bb.html</url>
    <content type="text"><![CDATA[前言调试, 是编写程序过程中确保程序正确性的重要环节, 现在使用的IDE大多都集成了调试器, 但linux最著名的调试器是命令行形式的C/C++调试器GDB。以下将介绍GDB的基本使用方法。安装GDB大多数的发行版Linux系统中都有GDB¶Debian 或 Ubuntu$ sudo apt-get install gdb¶Arch Linux$ sudo pacman -S gdb¶Fedora, CentOS 或 RHEL$ sudo yum install gdb也可以从官网中下载。示例代码学习任何一项技能, 动手试验才是关键。以下是本文演示GDB的代码, 多文件调试, 它可以很好的体现GDB的特性。将它拷贝下来并且进行实验——这是最好的方法。**a.c**1234567891011121314151617#include &lt;stdio.h&gt;#include "b.h"#include "c.h"int main(int argc,char**argv)&#123; long d,result=1,i=0,dresult,sum; printf("please input your student number:\n"); scanf("%ld",&amp;d);dresult=d%100; while(d&gt;0) &#123; result+=(d%100)&amp;1; d=d/100; &#125; while(i++&lt;150)&#123; sum=sqrt(dresult); dresult=sum+1; &#125; mytool1_print(":"); mytool2_print(":"); printf("your numbers are %ld,%ld\n",cresult,sum);&#125;**b.h**1234#ifndef _MYTOOL_1_H#define _MYTOOL_1_Hvoid mytool1_print(char*print_str);#endif**b.c**12345678#include&lt;stdio.h&gt;#include "b.h"#include "c.h"void mytool1_print(char*print_str)&#123; printf("1 %s\n",print_str); mytool2_print("2");&#125;**c.h**123456#ifndef _MYTOOL_2_H#define _MYTOOL_2_Hvoid mytool2_print(char* print_str);long sqrt(long d);extern long cresult;#endif**c.c**123456789101112131415#include "c.h"#include &lt;stdio.h&gt;long cresult=0;long d1result=0;long sqrt(long re)&#123; if(cresult==0)cresult=re%100/10+(re%10)*(re%10); if(d1result&gt;=140)return cresult*cresult+1; if(++d1result&gt;=128)return cresult+10; return re*re*re%1000;&#125;void mytool2_print(char* print_str)&#123; printf("2: %s\n",print_str);&#125;GDB的使用¶编译Debug程序首先最重要的, 你需要使用编译器的&quot;-g&quot;选项来编译程序, 这样可执行程序才能通过GDB来运行。1$ gcc a.c b.c c.c -g -o mydebug开始调试1$ gdb -tui [可执行程序名]使用'-tui'选项可以将代码显示在一个漂亮的交互式窗口内(所以被称为文本用户界面TUI), 在这个窗口内可以滚动鼠标滑轮, 同时在下面的GDB shell中输入命令。¶查看代码 list我们可以使用list命令来显示代码, 使用方法有12list [file:]start[,end]list [file:]function¶1. 查看c.c的第1行1list c.c:1or 简写1l c.c:1¶2. 查看b.c的3到8行1list b.c:3,8or 简写1l b.c:3,8¶3. 查看c.c的mytool2_print函数1list c.c:mytool2_printor 简写1l c.c:mytool2_print¶运行程序 rungdb 输入run即可运行程序1run¶设置断点 break1234break [file:]行号 break [file:]行号 if 条件 break [file:]函数 break *address¶1. 在a.c第10行设置断点12list a.c:1break 10or1break a.c:10从图可见, 文本用户界面TUI下, 设置断点会标志在文本的左侧¶2. 在a.c main函数开始处设置断点12list a.c:1break mainor1break a.c:main¶3. 在a.c的第10行设置条件断点条件断点的意思是, 当条件满足时, 断点会被执行; 条件不满足, 断点不会被执行1break a.c:10 if i == 150设置了当i等于150时, 执行断点, 方便在调试循环的时候, 想调试第几次循环的结果¶设置观察点 watch设置一个'观察断点', 当这个被观察的变量发生变化时, 程序会被停止。123watch 变量 (发生变化时暂停运行) rwatch 变量 (被访问时暂停运行) awatch 变量 (发生被访问或改变时暂停运行)¶1. 给a.c中的sum变量设置观察点1234list a.c:1break mainrunwatch sum观察点要在程序运行的时候才能设置¶继续运行continue遇到断点时, 要继续向下运行到下一个断点或者运行到结束程序, 使用continue命令¶跳出循环until在执行完循环体内的最后一条语句之后执行 until, 就会执行完循环体到后面的一个语句停下。PS: 就是循环体要执行一遍, 回到循环判断条件, 再执行until命令就会跳出循环¶查看变量值 printprint用来查看变量的值12print 变量p 变量ptype用来查看变量的类型1ptype 变量¶修改变量的值 set这样会覆盖变量的值。不过需要注意, 你不能创建一个新的变量或改变变量的类型。1set var [变量] = [新的值]¶单步调试step 运行到下一条语句, 有可能进入到一个函数里面1stepnext 直接运行下一条语句, 而不进入子函数内部1next¶删除断点12delete 断点号clear 断点所在行¶退出程序 quit1quit¶查看gdb内部命令 help1help 命令名¶complete 列出命令列出所有以字符串str开头的命令1complete str¶其他命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061info breakpoints (显示断点信息)info watchpoints (显示观察点信息)// 捕捉点catch event (event发生时, 程序暂停运行)tcatch event (设置只停一次的catchpoint, 第一次生效后, 该捕捉点被自动删除)event可以如下: exec: exec被调用 fork: fork被调用 load: 加载动态库 load libname: 加载名为libname的动态库 unload: 卸载动态库 unload libname: 卸载名为libname的动态库 syscall [args]: 调用系统调用, args可以指定系统调用号, 或者系统名称// 关于断点的disable(dis &lt;-命令简写) n 使断点n暂时失效enable(en &lt;-命令简写) n 恢复断点n功能// 函数调用call funcreturn [expr] 函数后续语句不再执行直接返回, expr可设置返回值finish 函数后续语句执行完返回// 搜索当前文件, 模式搜索forward-search regexp (行首开始) search regexp (当前行开始)reverse-search regexp (行尾开始)// 查看运行数据print命令 print [/fmt] exp当被调试的程序停止时, 可以用print命令（简写为p）或同义命令inspect来查看当前程序中运行的数据。 gdb所支持的表达式中的运算符 用&amp;运算符取出变量在内存中的地址。print &amp;array[i] &#123; type &#125;adrexp 表示一个数据类型为type、存放地址为adrexp的数据。&#123;&#125; @ 它是一个与数组有关的双目运算符 print a[2]@3 file::var 或者 function::var 表示文件file（或函数function）中变量var的值。 如&apos;f1.c&apos;::pwhatis命令显示出变量的数据类型 x命令可以查看内存地址中数据的值。其使用格式是: x [/nfu] addressdisplay命令可以预先设置一些要显示的表达式, 当程序停住时, 或是在你单步跟踪时, 变量会自动显示, 其一般格式为: display [/fmt] exp 取消对先前设置的某些表达式的自动显示功能, 可使用以下命令: undisplay [disnum] delete display [disnum]// 堆栈跟踪backtrace (bt) 打印当前的函数调用栈的所有信息frame(f) n 切换当前堆栈, n是一个从0开始的整数, 是栈中的层编号。比如：frame 0, 表示栈顶, frame 1, 表示栈的第二层。info frame(f) 显示出当前栈帧的所有信息, 如函数地址, 调用函数的地址, 被调用函数的地址, 目前函数的程序语言、函数参数地址及值、局部变量的地址等。]]></content>
      <categories>
        <category>C/C++</category>
        <category>gdb</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux grep命令与正则表达式]]></title>
    <url>%2Fposts%2F790da0f0.html</url>
    <content type="text"><![CDATA[前言grep是一种强大的文本搜索工具, 它能使用正则表达式搜索文本, 并把匹配的行打印出来。通常grep有三种版本grep、egrep(egrep等同于grep -E)和fgrep。egrep为扩展的grep, fgrep则为快速grep(固定的字符串来对文本进行搜索, 不支持正则表达式的引用但是查询极为快速)。grep是Linux文本处理三剑客之一。grep的使用使用方式:grep [OPTIONS] PATTERN [FILE...]orgrep [OPTIONS] [-e PATTERN | -f FILE] [FILE...]常用选项:–color=auto: 对匹配到的文本着色后进行高亮显示;-i: 忽略字符的大小写-o: 仅显示匹配到的字符串-v: 显示不能被模式匹配到的行-E: 支持使用扩展的正则表达式-q: 静默模式, 即不输出任何信息-A #: 显示被模式匹配的行及其后#行-B #: 显示被模式匹配的行及其前#行-C #: 显示被模式匹配的行及其前后各#行注: 使用grep匹配时需使用双引号引起来(单引号为强引用), 防止被系统误认为参数或者特殊命令而报错。扩展grep使用方式使用方式:egrep [OPTIONS] PATTERN [FILE...]orgrep -E [OPTIONS] PATTERN [FILE...]常用选项:-i: 忽略字符的大小写-o: 仅显示匹配到的字符串本身-v: 显示不被模式匹配到的行-q: 静默模式, 即不输出任何信息-A #: 显示被模式匹配的行及其后#行-B #: 显示被模式匹配的行及其前#行-C #: 显示被模式匹配的行及其前后各#行-G: 支持基本正则表达式grep正则表达式元字符'^': 锚定行首'$': 锚定行尾'.': 匹配任一一个字符'': 匹配零个或多个先前字符*'?': 匹配其前面的字符0次或者1次;'+': 匹配其前面的字符1次或者多次;'{m}': 匹配其前面的字符m次(\为转义字符)'{m,n}': 匹配其前面的字符至少m次, 至多n次'[]': 匹配一个指定范围内的字符 或者 '[^]'匹配指定范围外的任意单个字符'&lt;'或'\b': 锚定词首'&gt;'或'\b': 锚定词尾(可用&lt;PATTERN&gt;: 匹配完整单词)'()': 将多个字符当做一个整体进行处理¶关于后向引用后向引用: 引用前面的分组括号中的模式所匹配到的字符分组括号中的模式匹配到的内容或被正则表达式引擎自动记录于内部的变量中:\1: 模式从左侧起, 第一个左括号及与之匹配的右括号之间模式匹配到的内容\2: 模式从左侧起, 第二个左括号及与之匹配的右括号之间模式匹配到的内容扩展正则表达式与正则表达式略有不同¶关于'[]'的不同'[]': 依旧匹配指定范围内的任意单个字符;但是有很多特殊匹配方式:[:digit:] 匹配任意单个数字[:lower:] 匹配任意单个小写字母[:upper:] 匹配任意单个大写字母[:alpha:] 匹配任意单个字母[:alnum:] 匹配任意单个字母或数字[:punct:] 匹配任意单个符号[:space:] 匹配单个空格¶扩展正则不需要转义字符的地方一些地方取消了转义字符的使用:'?': 匹配其前面的字符0次或者1次;'+d': 匹配其前面的字符1次或者多次;'{m}': 匹配其前面的字符m次(\为转义字符)'{m,n}': 匹配其前面的字符至少m次, 至多n次(): 将一个或多个字符捆绑在一起, 当做一个整体进行处理, 反向引用照常使用。'|': 或 (注: 'C|cat'为C与cat, '(C|c)at才是Cat与cat')]]></content>
      <categories>
        <category>Linux</category>
        <category>Command</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Command</tag>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决python wordcloud中文乱码, 中文词频问题]]></title>
    <url>%2Fposts%2Fb82d5d51.html</url>
    <content type="text"><![CDATA[前言python的wordcloud可以很方便的生成词云图, 然而美中不足的是, 该库对中文支持并不是那么友好, 存在以下两个问题中文字符会乱码中文分词有问题以下介绍如何解决解决中文乱码wordcloud 不支持显示中文, 可以通过如下修改来支持中文:进入python根目录, 然后进入Lib\site-packages\wordcloud进入C:\Windows\Fonts目录下, 拷贝一个中文字库, 如华文新魏, 将其复制粘贴到Lib\site-packages\wordcloud目录下打开Lib\site-packages\wordcloud目录下wordcloud.py, 找到如下这行代码将代码改为对应拷入进来的字库名字, 如华文新魏的字库名字为STXINWEI.TTF至此解决中文乱码问题解决中文分词问题wordcloud的WordCloud类中的generate方法是先对传进去的文字进行分词, 但是对中文的分词效果不太好, 建议先自己计算词频, 存放到字典中, 然后使用generate_from_frequencies来生成词云&#123;cmd123456789101112131415161718192021222324from wordcloud import WordCloudimport matplotlib as mplimport matplotlib.pyplot as pltmpl.rcParams['font.sans-serif'] = ['SimHei'] # 指定默认字体 SimHei为黑体mpl.rcParams['axes.unicode_minus'] = False # 用来正常显示负号text = '清华大学清华大学北京大学北京大学暨南大学'textDic = &#123; '清华大学': 2, '北京大学': 2, '暨南大学': 1&#125;wc1 = WordCloud().generate(text) # generate对中文分词效果不好wc2 = WordCloud().generate_from_frequencies(textDic) # 自己来计算词频, 改善效果plt.title('generate生成的词云')plt.imshow(wc1, interpolation="bilinear")plt.axis("off")plt.figure()plt.title('自己计算词频')plt.imshow(wc2, interpolation="bilinear")plt.axis("off")plt.show()]]></content>
      <categories>
        <category>Python</category>
        <category>Wordcloud</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Wordcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国内各高校专业评比数据分析, python 词云、爬虫、数据分析]]></title>
    <url>%2Fposts%2F92d0ece7.html</url>
    <content type="text"><![CDATA[源代码 github: https://github.com/VonSdite/SchoolRank数据来源中国学位与研究生教育信息网 =&gt; http://www.cdgdc.edu.cn/xwyyjsjyxx/xkpgjg/数据是全国第四轮学科评估结果，该数据于2017年12月28日发布目的做这个脚本的缘由,因为身边总有同学要讨论哪个高校哪个高校比较优秀, 讲道理, 要看哪个高校优秀, 还是要具体到高校的具体专业, 口说无凭, 数据说话可以方便大家知道某个高校的强势在哪里脚本介绍¶需要的第三方库wordcloud: pip install wordcloudpandas: pip install pandasnumpy: pip install numpymatplotlib: pip install matplotlibpillow: pip install pillowrequests: pip install requestsBeautifulSoup: pip install beautifulsoup4¶show.py展示学校的评估结果¶使用在该项目目录下打开终端键入 show.py [学校名] 即可比如,show.py 暨南大学如果想比较多个学校之间的评估结果, 可以这样操作show.py 西安交通大学 中山大学¶GetSomeData/GetSchoolRank.py用于获取高校评估的脚本使用爬虫来获取 全国第四轮学科评估结果, 将数据保存为了 schoolRank.xlsx, 保存为.xlsx文件是为了方便使用excel进行操作(也可以自己保存为.csv文件来进行数据处理, 代码中已注释)¶schoolRank.xlsx数据展示可以通过excel来筛选查看数据(比自己造轮子来的方便多了)比如, 查看 暨南大学的评估结果¶GetSomeData/AssessmentAnalysis.py用于统计每个学校得到各个评估的次数通过pandas简易处理下数据, 将数据保存为了 schoolRank.xlsx, 保存为.xlsx文件是为了方便使用excel进行操作(也可以自己保存为.csv文件来进行数据处理, 代码中已注释)¶schoolAssementCount.xlsx数据展示同样可以通过excel来筛选查看数据¶GetSomeData/GetWordCloud.py以schoolRank.xlsx中的学校名来作词云, 实际就是按学校参加评估的总次数来画词云该项目生成的词云如下:¶注意注意1wordcloud 不支持显示中文, 可以通过如下修改来支持中文:进入python根目录, 然后进入Lib\site-packages\wordcloud进入C:\Windows\Fonts目录下, 拷贝一个中文字库, 如华文新魏, 将其复制粘贴到Lib\site-packages\wordcloud目录下打开Lib\site-packages\wordcloud目录下wordcloud.py, 找到如下这行代码将代码改为对应拷入进来的字库名字, 如华文新魏的字库名字为STXINWEI.TTF至此解决中文乱码问题注意2wordcloud的WordCloud类中的generate方法是先对传进去的文字进行分词, 但是对中文的分词效果不太好, 建议先自己计算词频, 存放到字典中, 然后使用generate_from_frequencies来生成词云&#123;cmd123456789101112131415161718192021222324from wordcloud import WordCloudimport matplotlib as mplimport matplotlib.pyplot as pltmpl.rcParams['font.sans-serif'] = ['SimHei'] # 指定默认字体 SimHei为黑体mpl.rcParams['axes.unicode_minus'] = False # 用来正常显示负号text = '清华大学清华大学北京大学北京大学暨南大学'textDic = &#123; '清华大学': 2, '北京大学': 2, '暨南大学': 1&#125;wc1 = WordCloud().generate(text) # generate对中文分词效果不好wc2 = WordCloud().generate_from_frequencies(textDic) # 自己来计算词频, 改善效果plt.title('generate生成的词云')plt.imshow(wc1, interpolation="bilinear")plt.axis("off")plt.figure()plt.title('自己计算词频')plt.imshow(wc2, interpolation="bilinear")plt.axis("off")plt.show()]]></content>
      <categories>
        <category>Python</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
        <tag>Wordcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给CSDN每篇文章开头加入新博客地址]]></title>
    <url>%2Fposts%2F50946eb.html</url>
    <content type="text"><![CDATA[前言众所周知, CSDN有点越来越恶心, 广告也越来越多, 但是之前在CSDN发布的文章的作用不能这样就丢了呀。所以写了个脚本, 给CSDN中的每篇文章开头加入新博客网站的地址, 以此来引流。Github 仓库 =&gt; https://github.com/VonSdite/CSDN_AddSomethingToYourBlog环境¶需要有Chrome有Chrome浏览器下载Chrome对应的ChromeDriver(点击找到对应版本下载), 并配置到环境变量中¶Python第三方库¶1. selenium通过pip install selenium 安装¶2. configobj通过pip install configobj 安装使用只需要在config.ini文件中配置好你的CSDN账号你的CSDN密码将要在文章开头添加的然后 运行AddSomethingToYourBlog.py即可AddSomethingToYourBlog.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import timefrom configobj import ConfigObjfrom selenium import webdriverconf = ConfigObj('config.ini', encoding='utf-8')text = conf['CSDN']['text']username = conf['CSDN']['username']password = conf['CSDN']['password']# 用来判断加载完没有def Wait(driver, text): while not text in driver.execute_script("return document.documentElement.outerHTML"): passdef AddSomethingToYourBlog(text, username, password): driver = webdriver.Chrome() driver.get('https://mp.csdn.net/postlist/') driver.find_element_by_css_selector('#app &gt; div &gt; div &gt; div &gt; div.main-login &gt; div.main-select &gt; ul &gt; li:nth-child(1) &gt; a').click() Wait(driver, '手机号/邮箱/用户名') driver.find_element_by_css_selector('#all').send_keys(username) driver.find_element_by_css_selector('#password-number').send_keys(password) driver.find_element_by_css_selector('#app &gt; div &gt; div &gt; div &gt; div.main-login &gt; div.main-process-login &gt; form &gt; div &gt; div:nth-child(6) &gt; div &gt; button').click() Wait(driver, '开始创作') driver.find_element_by_css_selector('#btnStart').click() while True: div = driver.find_elements_by_css_selector('.article-list-item') for nth in range(len(div)): div[nth].find_element_by_css_selector('div.list-item-title &gt; p &gt; a').click() driver.switch_to.window(driver.window_handles[-1]) if '富文本编辑器' in driver.execute_script("return document.documentElement.outerHTML"): driver.switch_to.frame(0) driver.execute_script("document.getElementsByClassName('htmledit_views cke_editable cke_editable_themed cke_contents_ltr cke_show_borders')[0].innerHTML='&lt;h3&gt;&lt;span style=\"color:#f33b45;\"&gt;&lt;strong&gt;%s&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;' + document.getElementsByClassName('htmledit_views cke_editable cke_editable_themed cke_contents_ltr cke_show_borders')[0].innerHTML" % text) driver.switch_to.default_content() driver.find_element_by_css_selector('#radChl &gt; option:nth-child(13)').click() driver.find_element_by_css_selector('#btnPublish').click() Wait(driver, '&lt;div class="alert-container finished-box" id="alertSuccess" style="display: block;"&gt;') driver.close() driver.switch_to.window(driver.window_handles[-1]) else: pre = driver.find_element_by_css_selector('body &gt; div.app.app--light &gt; div.layout &gt; div.layout__panel.flex.flex--row &gt; div.layout__panel.flex.flex--column &gt; div.layout__panel.flex.flex--row &gt; div.layout__panel.layout__panel--editor &gt; div.editor &gt; pre') driver.execute_script("var div=document.createElement('div');div.className='cledit-section';div.innerHTML='&lt;span class=\"token url\"&gt;# %s \\n&lt;/span&gt;&lt;span class=\"lf\"&gt;&lt;br&gt;&lt;span class=\"hd-lf\" style=\"display: none\"&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\"lf\"&gt;&lt;br&gt;&lt;span class=\"hd-lf\" style=\"display: none\"&gt;&lt;/span&gt;&lt;/span&gt;';arguments[0].insertBefore(div, document.getElementsByClassName('cledit-section')[0]);" % text, pre) driver.find_element_by_css_selector('body &gt; div.app.app--light &gt; div.layout &gt; div.layout__panel.layout__panel--articletitle-bar &gt; div &gt; div.article-bar__user-box.flex.flex--row &gt; button').click() Wait(driver, '保存为草稿') driver.find_element_by_css_selector('body &gt; div.app.app--light &gt; div.modal &gt; div &gt; div &gt; div.modal__button-bar &gt; button.button.btn-c-blue').click() Wait(driver, '&lt;div id="alertSuccess" class="finished-box" style=""&gt;') driver.close() driver.switch_to.window(driver.window_handles[-1]) next_page = driver.find_element_by_css_selector('#pills-tabContent &gt; div.pagination-wrapper &gt; nav &gt; ul &gt; li:last-child &gt; a') if next_page.text == '': next_page.click() time.sleep(1) else: print('全部文章已添加完成') input('按任意键退出...') driver.quit() breakif __name__ == '__main__': AddSomethingToYourBlog(text, username, password)]]></content>
      <categories>
        <category>Python</category>
        <category>Selenium</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转) Copyleft和GFDL许可证]]></title>
    <url>%2Fposts%2F5ab63499.html</url>
    <content type="text"><![CDATA[文章转自: 阮一峰 Copyleft和GFDL许可证一、什么是copyleft要讲copyleft, 必须先讲copyright。&quot;版权&quot;这个词copyright, 按照字面解释, 就是&quot;复制的权利&quot;(copy+right)。这就是说, 只要是有版权的作品, 都是不等随便复制的。程序员Richard Stallman对此很不满, 认为这阻碍了创新, 不利于人们分享成果。因此, 他在上个世纪70年代创建了自由软件基金会FSF, 致力于智力成果的自由分享。如果你希望自己的作品自由传播, 最简单的方法就是声明放弃版权, 使作品进入公共领域(public domain)。但是, 这样做有一个缺点, 就是你无法防止某些人对你的作品进行加工, 然后把加工的作品变为他们的私有财产, 进行出售。所以, 只有一个人放弃版权是不够的, 必须保证后面的所有使用者都不会将其据为己有。因为这个原因, Richard Stallman设计出了copyleft的做法。所谓copyleft, 就是为作品附上一个许可证, 这个许可证基本上允许你对作品做任何事, 除了不能限制他人的自由, 即如果你对原作品修改后再发布, 那么你也必须使用同样的许可证。所以, 只要一个作品被copyleft了, 那么此后基于它的所有作品都会被copyleft。copyleft这个词, 是对copyright的戏谑, 故意与copyright对立, 比如我们经常看到copyrighted materials, 现在就有了copylefted materials。这个词好像很难找到合适的中文译名。copyright的标志是正写的圈c, copyleft的标志是反写的圈c。不过, 有一点需要注意, 虽然copyleft与copyright对立, 但是它是符合版权制度的, copyleft的作品也是有版权的。二、GPL和GFDL许可证copyleft只是一个规范(paradigm), 只要符合这个规范, 就属于copyleft许可证。Richard Stallman建立FSF以后, 主要提出了两个copyleft许可证: GPL许可证(GNU General Public License)和GFDL许可证(GNU Free Documentation License)。前者主要用于软件作品, 后者主要用于文字作品。一旦一个文字作品采用了GFDL许可证, 那么他人就可以自由使用这个作品, 包括用于商业用途, 唯一的条件是所有衍生作品也必须采用GFDL许可证。目前, 世界上最著名、最成功的使用GFDL的项目, 是维基百科wikipedia。这意味着, 如果你利用wikipedia的材料写成一本书, 那么你的这本书, 他人也可以自由使用。三、GFDL和CC的关系CC许可证中, 只有保留&quot;相同方式共享&quot;(share alike)权利的许可证, 才属于copyleft规范。也就是说, 只有&quot;署名-相同方式共享&quot;(cc-by-sa)和&quot;署名-非商业用途-相同方式共享&quot;(cc-by-nc-sa)这两种许可证, 达到了这个标准。当然, 这并不意味着其他cc许可证就不自由, 相反的, 单独的&quot;署名&quot;(cc-by)许可证提供的自由, 其实比前两种许可证都大, 因为它允许你将原作品变为私有财产。一个有趣的问题是, GFDL和CC是不兼容的。虽然这两个许可证都允许自由使用作品, 但是你不能将它们混合在同一个作品里使用。在基本精神上, GFDL其实等同于cc-by-sa(署名-相同方式共享), 但是两者都要求衍生作品必须使用与原作品相同的许可证, 这使得它们没有办法互换。唯一可以单向互换的是GFDL和cc-by(署名)许可证: 使用cc-by的文字, 可以加入使用GFDL的文章, 但是反过来就不行。在现实中, Flickr采用的是CC许可证, 那么上面那些采用cc-by的照片, 是可以加入wikipedia的, 而那些采用cc-by-sa的照片勉强也可以加入, 因为wikipedia会对单张图片注明该照片采用cc-by-sa的许可证。但是, 使用cc-by-sa的文字就不能加入, 因为wikipedia对文字统一采用GFDL许可证。2007年12月, 创作共用基金会决定修改cc-by-sa许可证, 允许将其并入GFDL。从此以后, wikipedia也就可以加入采用cc-by-sa的文字了。]]></content>
      <categories>
        <category>License</category>
      </categories>
      <tags>
        <tag>License</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)创作公用许可证CC (Creative Commons licenses)]]></title>
    <url>%2Fposts%2Fb16e73a9.html</url>
    <content type="text"><![CDATA[文章转自: 阮一峰 谈谈创作共用许可证(Creative Commons licenses)一、创作共用许可证的起源自从**版权制度(copyright)**确立以后, 很多人感到, 虽然它保护了作者的利益, 但是却剥夺了使用者的自由。除了费用以外, 一个主要的问题是, 通行的版权协议是一种限制性的协议, 就是说, 只有它明文许可你可以做的事, 你才能做, 否则就是侵权行为。这样不仅很不方便, 而且阻碍了作品的传播, 违背社会公共利益, 尤其是在新传播方式层出不穷的网络时代。因此, 一些有识之士决定找到一种新的方法, 在版权制度的合法框架下, 使得人们可以自由使用他人的作品。这种新方法就是**&quot;开放内容许可证&quot;(open content licenses)**。简单说, 就是作者为自己的作品选择一种许可证一起发布, 然后这些许可证本身都是开放式协议, 就是说, 它只明文禁止使用者不能做的事, 除此以外, 可以随意使用这些作品。创作共用许可证(Creative Commons licenses, 简称cc), 就是这样一种许可证。它是由成立于2001年的美国Creative Commons基金会, 在2002年12月16日提出的。二、为自己的作品选择许可证为什么是重要的我们经常可以在书籍、电影、或者其他地方, 看到**&quot;保留所有权利&quot;(all rights reserved)**这句话, 这是一般的版权协议(full copyright)的基本内容, 就是说, 所有与作品有关的权利都归版权持有人所有。另一方面, 我们知道, **公共领域(public domain)**的作品是没有版权的, 所有权利都归使用者。因此, 普通的版权协议和公共领域, 正好是两个极端, 一个是保留所有权利, 另一个则是放弃所有权利。创作共用许可证, 则是在两个极端之间。它只保留几种了权利(some rights reserved), 除此以外的权利全部放弃。当你在网上(或者其他地方)发布自己的作品时, 如果允许他人自由使用, 那么最好选择一种许可证一起发布。因为, 如果你不同时发布许可证的话, 根据版权法, 你的作品就拥有完全的版权, 默认保留所有权利, 即便这不是你的意愿。**比如说, ** 你在github发布代码, 但你没发布许可证, 则默认保留所有权利。从小处说, 这阻碍了作品的传播。从大处说, 这限制了他人的自由, 最终也会限制你自己的自由。所以, 尽可能为作品选择一种许可证一起发布, 这是很重要的。三、创作共用许可证的基本权利如果你希望在满足某些条件的前提下, 使用者可以实施如下行为, 那么你就可以考虑使用创作共用许可证。换言之, 下面这些权利是你自动让渡给使用者的:复制作品;散发作品;公开展示或表演作品;将作品完全一致地转化成另一种格式。对于使用者来说, 虽然他免费拥有了这些权利, 但是必须遵守一些许可证设置的前提条件:没有得到许可, 不得实施许可证中禁止的行为;所有的复制件上, 都必须保留原始的版权说明和许可证的链接;不得更改许可证的内容;不得用技术手段限制其他人合法使用作品。以上的权利和义务, 被称为创作共用许可证的基本权利(Baseline Rights)。此外, 作品发布人还必须知道的是, 一旦选择了一种许可证, 并且公开发布以后, 就不能够收回了。这个许可证在整个版权保护期内, 对全世界的使用者都是有效的。(一个变通的方法是, 你可以在另一种许可证下, 发布作品的另一个版本。)四、创作共用许可证保留的权利使用创作共用许可证, 作者可以选择保留四种权利。署名(Attribution, 简写为by) ：必须提到原作者。非商业用途(Noncommercial, 简写为nc) ：不得用于盈利性目的。禁止演绎(No Derivative Works, 简写为nd) ：不得修改原作品。相同方式共享(Share Alike, 简写为sa) ：如果允许修改原作品, 那么必须使用相同的许可证发布。五、创作共用许可证的种类上面4种权利, 你可以全部保留, 也可以全部放弃。运用排列组合知识, 我们知道一共有16种不同的组合, 每一种组合就对应一种不同的许可证。这16种组合中, 有5种是无效的：1种是4种权利都放弃, 这就等于是公共领域作品；另外4种是不能同时选择禁止演绎和相同方式共享, 这两种权利。在剩下的11种组合中, 由于绝大多数人都要求保留署名权, 因此又可以排除5种。最终只留下了6种组合, 绝大多数创作共用许可证都属于这6种组合之一：署名(by license)署名-非商业用途(by-nc license)署名-禁止演绎(by-nd license)署名-非商业用途-禁止演绎(by-nc-nd license)署名-非商业用途-相同方式共享(by-nc-sa license)署名-相同方式共享(by-sa license)这6种组合中, 最宽松的是第一种署名许可证, 限制性最强的是第四种署名-非商业用途-禁止演绎许可证。所以, 准确的说, 创作共用许可证不是一种许可证, 而是一系列许可证的总称。六、如何使用创作共用许可证对于网上的作品, 你可以到这个网址http://creativecommons.org/license/, 去进行选择, 根据网页上的提示, 一步步操作, 最后将系统给出的代码放置在网页上即可。对于网下的作品, 你在选择好许可证后, 可以在作品上写下一段话：&quot;本作品采用创作共用[插入许可证的描叙]许可证授权。如要查看许可证全文, 请访问如下网址[插入网址url]。&quot;(This work is licensed under the Creative Commons [insert description] License. To view a copy of this license, visit [insert url].)需要注意的是, 对应不同的司法管辖区, 创作共用许可证有不同的地区版本。另外, 创作共用许可证一直在修订, 最新的是3.0版, 但是一部分地区还在使用2.5版。]]></content>
      <categories>
        <category>License</category>
      </categories>
      <tags>
        <tag>License</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GNU的三个协议条款GPL LGPL GFDL的介绍]]></title>
    <url>%2Fposts%2Fa094f759.html</url>
    <content type="text"><![CDATA[前言GNU 包含3个协议条款:GPL ：GNU通用公共许可证(GNU General Public License)LGPL：GNU较宽松公共许可证 (GNU Lesser General Public License )GFDL：GNU自由文档许可证(GNU Free Documentation License )。GPLGNU通用公共许可证(GNU General Public License),允许软件商业化销售, 但不允许封闭源代码。意思就是使用了GPL License就必须开源, 而且对遵循GPL的软件进行任何改动和/或再次开发并予以发布, 则必须也继承GPL协议, 不允许封闭源代码。¶例子比如, 只要软件A 引用/修改/衍生了 使用GPL协议的产品B, 软件A也必须使用GPL协议。 比如代码中引用了GPL协议的产品B代码中的一个类库, 这个软件A也必须使用GPL协议¶应用场景不适合商业软件对代码有保密要求的部门LGPLGNU较宽松公共许可证(GNU Lesser General Public License), 允许软件商业化销售, 但不允许封闭源代码。意思就是使用了LGPL License就必须开源, 而且对遵循LGPL的软件进行任何改动和/或再次开发并予以发布, 则您的产品必须继承LGPL协议, 不允许封闭源代码。但是如果您的程序对遵循LGPL的软件进行任何连接、调用而不是包含, 则允许封闭源代码。¶例子允许商业软件通过类库引用方式来使用LGPL类库的产品, 且不需要开源商业软件的代码(引用LGPL类库, 商业软件不需要使用LGPL协议, 所以可以封闭源代码)。但是如果修改LGPL协议的代码或者衍生, 则所有修改的代码、涉及修改部分的额外代码和二次开发的代码都必须采用LGPL协议, 意思就是要开源。¶应用场景LGPL类库适合作为第三方类库被商业软件引用不适合希望以LGPL协议代码为基础, 通过修改和衍生的方式做二次开发的软件采用。GFDLGNU自由文档许可证(GNU Free Documentation License ), 自由软件的通用版权认证协议。GFDL主要用于文字作品。一旦一个文字作品采用了GFDL许可证, 那么他人就可以自由使用这个作品, 包括用于商业用途, 唯一的条件是所有衍生作品也必须采用GFDL许可证。¶应用场景目前, 世界上最著名、最成功的使用GFDL的项目, 是维基百科wikipedia。这意味着, 如果你利用wikipedia的材料写成一本书, 那么你的这本书, 他人也可以自由使用。]]></content>
      <categories>
        <category>License</category>
      </categories>
      <tags>
        <tag>License</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ps 设置照片为一寸照片26mm*32mm/307*377像素]]></title>
    <url>%2Fposts%2Fbd39d7be.html</url>
    <content type="text"><![CDATA[前言有时候手上有了证件照的原件, 但有时候比如需要照片为一寸照片, 即26mm * 32mm/ 307 * 377像素, 此时可能就需要修改一下图片的尺寸。下文介绍如何修改。吐槽一下： 打印店帮你改个尺寸还要收个10块钱, 还是自力更生吧。前提有Photoshop有证件照修改操作如下是要修改的证件照, 当前的图像大小信息如图, 显然还不是26mm * 32mm/ 307 * 377像素¶方法一点击裁剪工具点击大小和分辨率设置宽度为 2.6厘米, 高度为 3.2厘米, 分辨率不填, 然后点击确定通过方向键来移动裁剪框, 移动至合适位置裁剪即可(PS本文例子图基本不需要移动了, 尺寸已基本是2.6*3.2)裁剪后, 通过快捷键ctrl+alt+I查看图像大小, 如图。还未达到我们的要求, 此时只需要将分辨率设置为300就可以完成我们的需求了¶方法二通过快捷键ctrl+alt+I查看图像大小, 然后设置分辨率为300接着设置宽度像素为307, 此时一般高度像素还没达到我们的要求, 只是例子图片比较特殊, 接下来只要裁剪下高度即可完成要求点击裁剪工具点击大小和分辨率设置宽度为 2.6厘米, 高度为 3.2厘米, 分辨率不填, 然后点击确定通过方向键来移动裁剪框, 移动至合适位置裁剪即可最终完成我们的要求关于分辨率 300照片的冲洗的话, 分辨率DPI就要设置为300或更高, 网络上传照片72DPI已经可以看得清了DPI（Dots Per Inchd, 每英寸点数）是一个量度单位d, 用于点阵数码影像d, 指每一英寸长度中d, 取样、可显示或输出点的数目。DPI是打印机、鼠标等设备分辨率的度量单位。是衡量打印机打印精度的主要参数之一d, 一般来说d, DPI值越高d, 表明打印机的打印精度越高。DPI是指每英寸的像素d, 也就是扫描精度。DPI越低d, 扫描的清晰度越低d, 由于受网络传输速度的影响d, web上使用的图片都是72dpid, 但是冲洗照片不能使用这个参数d, 必须是300dpi或者更高350dpi。例如要冲洗46英寸的照片d, 扫描精度必须是300dpid, 那么文件尺寸应该是(4300)(6300)=1200像素*1800像素。]]></content>
      <categories>
        <category>Photoshop</category>
      </categories>
      <tags>
        <tag>Photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux umask的使用]]></title>
    <url>%2Fposts%2F11eb8483.html</url>
    <content type="text"><![CDATA[umask在Linux系统下, 创建一个文件/目录时, 系统都会给它赋予一个默认的权限, 这个默认权限就是umask设置的。umask设置了用户创建文件的默认权限, 它与chmod的效果刚好相反, umask设置的是权限的反码, 也叫作预设权限(权限掩码)你的系统管理员必须要为你设置一个合理的 `umask`值, 以确保你创建的文件具有所希望的缺省权限, 防止其他非同组用户对你的文件具有写权限。在已经登录之后, 可以按照个人的偏好使用`umask`命令来改变文件创建的缺省权限。相应的改变**直到退出该shell**或**使用另外的`umask`命令之前**一直有效。一般来说, umask命令是在/etc/profile文件中设置的, 每个用户在登录时都会引用这个文件, 所以如果希望改变所有用户的umask, 可以在该文件中加入相应的条目。如果希望永久 性地设置自己的umask值, 那么就把它放在自己$HOME目录下的.profile或.bash_profile文件中。umask的使用umask命令允许你设定文件创建时的缺省模式, 对应每一类用户(文件属主、同组用户、其他用户)存在一个相应的umask值中的数字。注意:对于文件来说, 权限数字的最大值是6。因为系统不允许你在创建一个文本文件时就赋予它执行权限, 必须在创建后用chmod命令增加这一权限。目录允许设置执行权限, 这样针对目录来说, umask中各个数字最大可以到7¶查看当前umask1234$ umask0002 # 只看后四位$ umask -Su=rwx,g=rwx,o=rwx # 字符形式查看¶设置umask1umask nnn # nnn为 000-777¶计算umask的值设置umask值后, 怎么快速得到创建文件的权限呢¶减法一种是使用减法。记住文件权限最大值是6, 目录权限最大值是7,当你umask 002, 那么文件得到的权限就是 664, 因为 6-0=6 6-0=6 6-2=4, 目录则是775¶异或另一种就是异或。记住文件权限最大值6的二进制是110, 目录权限最大值7的二进制是111,当你umask 002, 那么文件得到的权限就是 664, 因为二进制异或: 000110=110、000110=110、010^110=100, 所以权限就是664, 目录则是775]]></content>
      <categories>
        <category>Linux</category>
        <category>Command</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Command</tag>
        <tag>umask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 提升python速度]]></title>
    <url>%2Fposts%2F2a5aa04e.html</url>
    <content type="text"><![CDATA[前言可以使用 Cython, PyPy提升 python的速度CythonCython是让Python脚本支持C语言扩展的编译器, Cython能够将Python+C混合编码的.pyx脚本转换为C代码, 主要用于优化Python脚本性能或Python调用C函数库。由于Python固有的性能差的问题, 用C扩展Python成为提高Python性能常用方法, Cython算是较为常见的一种扩展方式。推荐文章:https://www.jianshu.com/p/fc5025094912https://www.cnblogs.com/yafengabc/p/6130849.htmlhttps://baijiahao.baidu.com/s?id=1606135207446878267&amp;wfr=spider&amp;for=pchttps://baijiahao.baidu.com/s?id=1606135207446878267&amp;wfr=spider&amp;for=pcCPython 与 PyPyCPython: 是用C语言实现Python, 是目前应用最广泛的解释器。最新的语言特性都是在这个上面先实现的, 基本包含了所有第三方库支持, 但是CPython有几个缺陷, 一是全局锁使Python在多线程效能上表现不佳, 二是CPython无法支持JIT（即时编译）, 导致其执行速度不及Java和Javascipt等语言。于是出现了Pypy。Pypy: 是用Python自身实现的解释器。针对CPython的缺点进行了各方面的改良, 性能得到很大的提升。最重要的一点就是Pypy集成了JIT。但是, Pypy无法支持官方的C/Python API, 导致无法使用例如Numpy, Scipy等重要的第三方库。这也是现在Pypy没有被广泛使用的原因吧。¶PyPy与CPython的不同CPython是使用解释执行的方式, 这样的实现方式在性能上是很凄惨的。而PyPy使用了JIT(即时编译)技术, 在性能上得到了提升。¶Python的解释器:由于Python是动态编译的语言, 和C/C++、Java或者Kotlin等静态语言不同, 它是在运行时一句一句代码地边编译边执行的, 而Java是提前将高级语言编译成了JVM字节码, 运行时直接通过JVM和机器打交道, 所以进行密集计算时运行速度远高于动态编译语言。PyPy, 它使用了JIT（即时编译）技术, 混合了动态编译和静态编译的特性, 仍然是一句一句编译源代码, 但是会将翻译过的代码缓存起来以降低性能损耗。相对于静态编译代码, 即时编译的代码可以处理延迟绑定并增强安全性。绝大部分 Python代码都可以在PyPy下运行, 但是PyPy和CPython有一些是不同的。一个速度比较例子使用C++和Python分别实现目录大小计算的算法。其中的要求是:计算单个目录大小, 返回一个数值计算目录及目录下所有子目录大小, 返回一个map表¶结果比较¶Python的运行结果单纯看Python的结果, 可以看出来线程池的优化大大提高了递归计算的速度, 将近提升了10倍的效率¶C++的运行结果通过比较单个目录大小计算, C比Python快了近5.6倍而计算所有目录大小, C比Python快了近5.6倍¶说明线程池的池子大小设为5。计算的目录都是E:\1Code\Repositories, 5.8G的大小为了避免全局线程池影响到其他函数的运行效率, 线程池实现的方法 单独运行两者的实现算法都是一致的¶Python实现了4种方法第一种是使用os.walk的生成器来遍历计算单个目录大小, 名为get_dir_size第二种是递归计算单个目录大小, 名为get_dir_size_recursive第三种是递归计算目录及目录下所有子目录大小, 名为get_all_dir_size第四种是线程池+递归计算目录及目录下所有子目录大小, 名为get_all_dir_size_thread¶C++实现了2种方法第一种是递归计算单个目录大小, 名为SimpleGetDirectorySizeRecursive第二种是递归计算目录及目录下所有子目录大小, 名为SimpleGetDirectorySize¶Python的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import osimport timeitimport threadingimport threadpoolfrom os.path import join, getsize, isdir, isfile# os.walk加列表推导式求单个目录的大小def get_dir_size(dir): size = 0 for root, dirs, files in os.walk(dir): size += sum([getsize(join(root, name)) for name in files]) return size# 递归求单个目录的大小def get_dir_size_recursive(dir): size = 0 for f in os.listdir(dir): ff = join(dir, f) if isdir(ff): size += get_dir_size_recursive(ff) elif isfile(ff): size += getsize(ff) return size# 去掉目录中的 `:` `\` `/`def clear_path_format(dir): return dir.replace(':', '').replace('\\', '').replace('/', '')# 递归求目录及所有子目录的大小dir_dict = dict()def get_all_dir_size(parent_dirs, dir): dir_dict[clear_path_format(dir)] = 0 size = 0 parent_dirs.append(clear_path_format(dir)) for f in os.listdir(dir): ff = join(dir, f) if isdir(ff): get_all_dir_size(parent_dirs, ff) elif isfile(ff): size += getsize(ff) if size &gt; 0: for path in parent_dirs: dir_dict[path] += sizedir_dict_thread = dict()pool = threadpool.ThreadPool(5)mutex = threading.Lock()def get_all_dir_size_thread(parent_dirs, dir): size = 0 parent_dirs.append(clear_path_format(dir)) for f in os.listdir(dir): ff = join(dir, f) if isdir(ff): mutex.acquire() pool.putRequest( threadpool.makeRequests( get_all_dir_size_thread, [ ( (parent_dirs.copy(), ff), None ) ] )[0] ) mutex.release() elif isfile(ff): size += getsize(ff) if size &gt; 0: mutex.acquire() for path in parent_dirs: dir_dict_thread.setdefault(path, 0) dir_dict_thread[path] += size mutex.release()if __name__ == "__main__": dir = r'E:\1Code\Repositories' print('Test "%s" size ////// just python' % dir) start = timeit.default_timer() size = get_dir_size(dir) end = timeit.default_timer() print('get_dir_size: %fGB-&gt; use time: %fs' % (size / (1 &lt;&lt; 30), end-start)) start = timeit.default_timer() size = get_dir_size_recursive(dir) end = timeit.default_timer() print('get_dir_size_recursive: %fGB -&gt; use time: %fs' % (size / (1 &lt;&lt; 30), end - start)) start = timeit.default_timer() get_all_dir_size([], dir) end = timeit.default_timer() print('get_all_dir_size: %fGB -&gt; use time: %fs' % (dir_dict[clear_path_format(dir)] / (1 &lt;&lt; 30), end - start)) start = timeit.default_timer() get_all_dir_size_thread([], dir) pool.wait() end = timeit.default_timer() print('get_all_dir_size_thread: %fGB -&gt; use time: %fs' % (dir_dict_thread[clear_path_format(dir)] / (1 &lt;&lt; 30), end - start))¶C++的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;unordered_map&gt;#include &lt;windows.h&gt;#include &lt;time.h&gt;using namespace std;#ifdef UNICODEtypedef wstring tstring;#elsetypedef string tstring;#endif#define POOL_SIZE 5unordered_map&lt;tstring, ULONGLONG&gt; mapDirSize_simple; // 递归的map表// 根据文件的高32位和低32位求出文件的大小ULONGLONG GetFileSize(ULONGLONG high, ULONGLONG low)&#123; return ((high &lt;&lt; 32) | low);&#125;// 去掉中所有的 "/" "\" ":" tstring ClearPathFormat(tstring path)&#123; size_t pos = 0; tstring clear1 = TEXT("/"); tstring clear2 = TEXT("\\"); tstring clear3 = TEXT(":"); while ((pos = path.find(clear1)) != tstring::npos) &#123; path.replace(pos, clear1.length(), ""); &#125; while ((pos = path.find(clear2)) != tstring::npos) &#123; path.replace(pos, clear2.length(), ""); &#125; while ((pos = path.find(clear3)) != tstring::npos) &#123; path.replace(pos, clear3.length(), ""); &#125; return path;&#125;// 简单递归得目录大小ULONGLONG SimpleGetDirectorySize(vector&lt;tstring&gt; vecParentPath, tstring lpDirName)&#123; ULONGLONG nDirSize = 0; // 文件夹大小 tstring strDirName = lpDirName; strDirName += TEXT("/*.*"); // 目录名字 HANDLE hFile; WIN32_FIND_DATA pNextInfo; hFile = FindFirstFile(strDirName.c_str(), &amp;pNextInfo); if (INVALID_HANDLE_VALUE == hFile) return 0; vecParentPath.push_back(ClearPathFormat(lpDirName)); while (FindNextFile(hFile, &amp;pNextInfo)) &#123; // 跳过 "." ".." 两个目录 if (!strcmp(pNextInfo.cFileName, ".") || !strcmp(pNextInfo.cFileName, "..")) continue; if (pNextInfo.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) &#123; // 目录, 递归下去加 tstring strTmp = lpDirName; strTmp += TEXT("/"); strTmp += pNextInfo.cFileName; SimpleGetDirectorySize(vecParentPath, strTmp.c_str()); &#125; else &#123; // 文件 nDirSize += GetFileSize(pNextInfo.nFileSizeHigh, pNextInfo.nFileSizeLow); &#125; &#125; if (nDirSize) &#123; for (auto parent : vecParentPath) &#123; mapDirSize_simple[parent] += nDirSize; &#125; &#125; return mapDirSize_simple[ClearPathFormat(lpDirName)];&#125;// 递归得单个目录大小ULONGLONG SimpleGetDirectorySizeRecursive(LPCSTR lpDirName)&#123; ULONGLONG nDirSize = 0; // 文件夹大小 TCHAR strDirName[1000]; memset(strDirName, 0, sizeof(strDirName)); memcpy(strDirName, lpDirName, strlen(lpDirName)); strcat(strDirName, TEXT("/*.*")); HANDLE hFile; WIN32_FIND_DATA pNextInfo; hFile = FindFirstFile(strDirName, &amp;pNextInfo); if (INVALID_HANDLE_VALUE == hFile) return 0; while (FindNextFile(hFile, &amp;pNextInfo)) &#123; // 跳过 "." ".." 两个目录 if (!strcmp(pNextInfo.cFileName, ".") || !strcmp(pNextInfo.cFileName, "..")) continue; if (pNextInfo.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) &#123; // 目录, 递归下去加 TCHAR strTmp[1000]; memset(strTmp, 0, sizeof(strTmp)); memcpy(strTmp, lpDirName, strlen(lpDirName)); strcat(strTmp, TEXT("/")); strcat(strTmp, pNextInfo.cFileName); nDirSize += SimpleGetDirectorySizeRecursive(strTmp); &#125; else &#123; // 文件 nDirSize += GetFileSize(pNextInfo.nFileSizeHigh, pNextInfo.nFileSizeLow); &#125; &#125; return nDirSize;&#125;int main()&#123; tstring strDirName = TEXT("E:\\1Code\\Repositories"); LARGE_INTEGER t1, t2, tc; // 递归计算单个目录大小 QueryPerformanceFrequency(&amp;tc); QueryPerformanceCounter(&amp;t1); cout &lt;&lt; strDirName &lt;&lt; " size: " &lt;&lt; (double)SimpleGetDirectorySizeRecursive(strDirName.c_str()) / (1 &lt;&lt; 30) &lt;&lt; "GB" &lt;&lt; endl; QueryPerformanceCounter(&amp;t2); printf("Use Time:%fs\n", (t2.QuadPart - t1.QuadPart)*1.0 / tc.QuadPart); // 递归计算目录大小 QueryPerformanceFrequency(&amp;tc); QueryPerformanceCounter(&amp;t1); vector&lt;tstring&gt; vecEmpty; cout &lt;&lt; strDirName &lt;&lt; " size: "&lt;&lt; (double)SimpleGetDirectorySize(vecEmpty, strDirName.c_str()) / (1 &lt;&lt; 30) &lt;&lt; "GB" &lt;&lt; endl; QueryPerformanceCounter(&amp;t2); printf("Use Time:%fs\n", (t2.QuadPart - t1.QuadPart)*1.0 / tc.QuadPart); return 0;&#125;]]></content>
      <categories>
        <category>Python</category>
        <category>Cython</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Cython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 使用Valine作评论系统]]></title>
    <url>%2Fposts%2Fc7d98860.html</url>
    <content type="text"><![CDATA[前言之前博客使用的是gitalk作为评论系统, 但是对于强迫症, 看到Github的Recent activity满满的一列Issue, 内心着实有点小难受。如果想使用gitalk作为评论系统的可以看**Hexo Next 加入评论功能gitalk**而想使用Valine作为评论系统, 则可以参考此文ValineValine 诞生于2017年8月7日, 是一款基于Leancloud的快速、简洁且高效的无后端评论系统。理论上支持但不限于静态博客, 目前已有Hexo、Jekyll、Typecho、Hugo 等博客程序在使用Valine。¶特性快速安全Emoji 😉无后端实现MarkDown 全语法支持轻量易用(~15kb gzipped)文章阅读量统计 v1.2.0+使用Valine可以上Valine的官网的快速开始查看如何配置以下专门介绍Hexo如何配置, Next主题是**6.0版本**以上的因为Valine是基于LeanCloud的, 所以我们先注册Leancloud并创建应用¶注册Leancloud并创建应用首先, 前往Leancloud官网leancloud.cn进行注册, 并登陆。点击创建应用输入应用的名称(随便起都行), 选择开发版, 点击创建创建成功后点击右上角的设置小齿轮创建后点击设置-点击应用Key-获取App ID和App Key将获取到的App ID和App Key设置到Next主题配置文件_config.yml, 并设置enable: true配置文件已存在这个配置, 只要把 id 和 key 加上去就好了123456789101112valine: # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. enable: true appid: &lt;&lt;your app id&gt;&gt; # your leancloud application appid appkey: &lt;&lt;your app key&gt;&gt; # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: ヾﾉ≧∀≦)o来啊, 快活啊! # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html点击安全中心, 填写自己博客对应的域名（注意协议、域名和端口号需严格一致）至此完成配置, hexo s就可以看到文章评论区了¶开启评论回复邮箱提醒参考评论系统中的邮件提醒设置Valine的配置要设置 notify: true 和 verify: true123456789101112valine: # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. enable: true appid: &lt;&lt;your app id&gt;&gt; # your leancloud application appid appkey: &lt;&lt;your app key&gt;&gt; # your leancloud application appkey notify: true # mail notifier , https://github.com/xCss/Valine/wiki verify: true # Verification code placeholder: ヾﾉ≧∀≦)o来啊, 快活啊! # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html¶评论数据管理由于Valine 是无后端评论系统, 所以也就没有开发评论数据管理功能。请自行登录Leancloud应用管理。具体步骤：登录&gt;选择你创建的应用&gt;存储&gt;选择Class Comment, 然后就可以尽情的发挥你的权利啦(～￣▽￣)～当然, 你也可以配合 @panjunwen 开发的 Valine-Admin 进行评论数据管理注意如果你某一篇文章不想有评论功能, 你可以在文章的font-matter中加入 comments: false因为加入了评论功能, 在标签、分类页面都会有个评论区, 所以应到相应页面的index.md的font-matter中加入 comments: false并修改站点目录下scaffolds的page.md模板, 因为创建page都会使用到该模板, 而页面不需要有评论区123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;type: comments: false---]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>Valine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python os模块 关于文件/目录常用的函数使用方法]]></title>
    <url>%2Fposts%2Fb288b56b.html</url>
    <content type="text"><![CDATA[常用的文件/目录函数函数名使用方法os.getcwd()返回当前工作目录os.chdir(path)改变工作目录os.listdir(path='.')列举指定目录中的文件名('.'表示当前目录, '…'表示上一级目录)os.mkdir(path)创建单层目录, 如该目录已存在抛出异常os.makedirs(path)递归创建多层目录, 如该目录已存在抛出异常, 注意: 'E:\a\b'和'E:\a\c'并不会冲突os.remove(path)删除文件os.rmdir(path)删除单层目录, 如该目录非空则抛出异常os.removedirs(path)递归删除目录, 从子目录到父目录逐层尝试删除, 遇到目录非空则抛出异常os.rename(old, new)将文件old重命名为newos.system(command)运行系统的shell命令os.walk(top)遍历top路径以下所有的子目录, 返回一个三元组: (路径, [包含目录], [包含文件])os.path模块关于路径常用的函数函数名使用方法os.path.basename(path)去掉目录路径，单独返回文件名os.path.dirname(path)去掉文件名，单独返回目录路径os.path.join(path1[, path2[, …]])将path1, path2各部分组合成一个路径名os.path.split(path)分割文件名与路径，返回(f_path, f_name)元组。如果完全使用目录，它也会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在os.path.splitext(path)分离文件名与扩展名，返回(f_name, f_extension)元组os.path.getsize(file)返回指定文件的尺寸，单位是字节os.path.getatime(file)返回指定文件最近的访问时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算）os.path.getctime(file)返回指定文件的创建时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算）os.path.getmtime(file)返回指定文件最新的修改时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算）¶以下返回值为 True 或 False函数名使用方法os.path.exists(path)判断指定路径（目录或文件）是否存在os.path.isabs(path)判断指定路径是否为绝对路径os.path.isdir(path)判断指定路径是否存在且是一个目录os.path.isfile(path)判断指定路径是否存在且是一个文件os.path.islink(path)判断指定路径是否存在且是一个符号链接os.path.ismount(path)判断指定路径是否存在且是一个挂载点os.path.samefile(path1, paht2)判断path1和path2两个路径是否指向同一个文件支持跨平台的路径定义函数名使用方法os.curdir指代当前目录('.')os.pardir指代上一级目录('…')os.sep输出操作系统特定的路径分隔符(Win下为'\', Linux下为'/')os.linesep当前平台使用的行终止符(Win下为'\r\n', Linux下为'\n')os.name指代当前使用的操作系统(包括: 'posix',]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python os</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 性能测试工具]]></title>
    <url>%2Fposts%2Fe1d29b4a.html</url>
    <content type="text"><![CDATA[timeit1234import timeitprint(timeit.timeit(stmt="[i for i in range(1000)]", number=100000)) # 传入的是字符串表达式# 输出: # 3.0182870961591375timeit只输出被测试代码的总运行时间, 单位为秒, 没有详细的统计.timeit的详细介绍点这里profile / cProfileprofile: 纯Python实现的性能测试模块, 接口和cProfile一样cProfile: c语言实现的性能测试模块, 接口和profile一样1234567891011121314151617&gt;&gt;&gt; import profile&gt;&gt;&gt; def fun():... for i in range(100000):... a = i * i...&gt;&gt;&gt; profile.run('fun()') 5 function calls in 0.016 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 1 0.000 0.000 0.016 0.016 :0(exec) 1 0.000 0.000 0.000 0.000 :0(setprofile) 1 0.016 0.016 0.016 0.016 &lt;stdin&gt;:1(fun) 1 0.000 0.000 0.016 0.016 &lt;string&gt;:1(&lt;module&gt;) 1 0.000 0.000 0.016 0.016 profile:0(fun()) 0 0.000 0.000 profile:0(profiler)123456789101112131415&gt;&gt;&gt; import cProfile&gt;&gt;&gt; def fun():... for i in range(100000):... a = i * i...&gt;&gt;&gt; cProfile.run('fun()') 4 function calls in 0.005 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 1 0.005 0.005 0.005 0.005 &lt;stdin&gt;:1(fun) 1 0.000 0.000 0.005 0.005 &lt;string&gt;:1(&lt;module&gt;) 1 0.000 0.000 0.005 0.005 &#123;built-in method builtins.exec&#125; 1 0.000 0.000 0.000 0.000 &#123;method 'disable' of '_lsprof.Profiler' objects&#125;¶解释12345678910111213141516171819202122232425&gt;&gt;&gt; import cProfile&gt;&gt;&gt; import re&gt;&gt;&gt; cProfile.run('re.compile("foo|bar")') 199 function calls (194 primitive calls) in 0.000 seconds Ordered by: standard name ncalls tottime percall cumtime percall filename:lineno(function) 1 0.000 0.000 0.000 0.000 &lt;string&gt;:1(&lt;module&gt;) 4 0.000 0.000 0.000 0.000 enum.py:265(__call__) 4 0.000 0.000 0.000 0.000 enum.py:515(__new__) 2 0.000 0.000 0.000 0.000 enum.py:801(__and__) 1 0.000 0.000 0.000 0.000 re.py:231(compile) 1 0.000 0.000 0.000 0.000 re.py:286(_compile) 1 0.000 0.000 0.000 0.000 sre_compile.py:223(_compile_charset) 1 0.000 0.000 0.000 0.000 sre_compile.py:250(_optimize_charset) 1 0.000 0.000 0.000 0.000 sre_compile.py:414(_get_literal_prefix) 1 0.000 0.000 0.000 0.000 sre_compile.py:441(_get_charset_prefix) 1 0.000 0.000 0.000 0.000 sre_compile.py:482(_compile_info) 2 0.000 0.000 0.000 0.000 sre_compile.py:539(isstring) 1 0.000 0.000 0.000 0.000 sre_compile.py:542(_code) 1 0.000 0.000 0.000 0.000 sre_compile.py:557(compile) 3/1 0.000 0.000 0.000 0.000 sre_compile.py:64(_compile) 3 0.000 0.000 0.000 0.000 sre_parse.py:111(__init__)····# 此处省略上述运行表明有199个函数被调用, 其中有194个原生调用(即不涉及递归调用)总共运行时间 0.000 seconds结果按标准名称进行排序列表中ncalls表示函数调用的次数(有两个数值表示有递归调用, 总调用次数/原生调用次数)tottime是函数内部调用时间(不包括他自己调用的其他函数的时间)第一个percall = tottime/ncallscumtime累积调用时间, 它包含了自己内部调用函数的时间第二个percall = cumtime/ncalls最后一列: 文件名, 行号, 函数名line_profilerline_profiler可以统计每行代码的执行次数和执行时间等, 时间单位为微秒。¶安装1pip install line_profiler安装之后, python 下会多一个kernprof.py¶使用在需要测试的函数加上@profile装饰, 这里我们测试代码test.py运行命令行: kernprof -l -v test.pyTotal Time: 测试代码的总运行时间File: 测试的代码名Function: 测试的函数所在的行Line #: 表示代码的行号Hits: 表示每行代码运行的次数Time: 每行代码运行的总时间, 时间单位为微秒Per Hits: 每行代码运行一次的时间, 时间单位为微秒% Time: 每行代码运行时间的百分比test.py1234567891011121314import time@profiledef fun(): a = 0 b = 0 for i in range(100000): a = a + i * i for i in range(3): b += 1 time.sleep(0.1) return a + b fun()memory_profilermemory_profiler工具可以统计每行代码占用的内存大小。¶安装12pip install memory_profiler pip install psutil¶使用在需要测试的函数加上@profile装饰执行命令: python -m memory_profiler test.pyPycharm图形化性能测试工具PyCharm提供了性能分析工具Run-&gt; Profile, 如下图所示。利用Profile工具可以对代码进行性能分析, 找出瓶颈所在¶使用测试代码见下文, 一共有5个函数, 每个函数都调用了time.sleep进行延时点击Run-&gt; Profile开始测试, 代码运行结束后会生成一栏测试结果,测试结果由两部分构成, Statistics(性能统计)和Call Graph(调用关系图)¶Statistics(性能统计)性能统计界面由Name、Call Count、Time(ms)、Own Time(ms) 4列组成一个表格。Name显示被调用的模块或者函数Call Count显示被调用的次数;Time(ms)显示运行时间和时间百分比, 时间单位为毫秒(ms), 包含自己内部调用函数的时间Own Time(ms)显示运行时间和时间百分比, 时间单位为毫秒(ms), 不包含自己内部调用函数的时间¶小技巧点击表头上的小三角可以升序或降序排列表格。在Name这一个列中双击某一行可以跳转到对应的代码。¶Call Graph(调用关系图)Call Graph(调用(系图), 包含了自己内部调用函数的时间界面直观展示了各函数直接的调用关系、运行时间和时间百分比。¶解释箭头表示调用关系, 由调用者指向被调用者;矩形的左上角显示模块或者函数的名称, 右上角显示被调用的次数;矩形中间显示运行时间和时间百分比;矩形的颜色表示运行时间或者时间百分比大小的趋势: 红色 &gt; 黄绿色 &gt; 绿色, 比如由图可以看出fun3的矩形为黄绿色, fun1为绿色, 所有fun3运行时间比fun1长。从图中可以看出test.py直接调用了fun3、fun1、fun2和fun5函数; fun5函数直接调用了fun4函数; fun1、fun2、fun3、fun4和fun5都直接调用了print以及sleep函数; 整个测试代码运行的总时间为6001ms, 其中fun3的运行时间为1999ms, 所占的时间百分比为33.3%, 也就是 1999ms / 6006ms = 33.3%。test.py1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-# __Author__: Sdite# __Email__ : a122691411@gmail.comimport timedef fun1(a, b): print('fun1') print(a, b) time.sleep(1)def fun2(): print('fun2') time.sleep(1)def fun3(): print('fun3') time.sleep(2)def fun4(): print('fun4') time.sleep(1)def fun5(): print('fun5') time.sleep(1) fun4()fun1('foo', 'bar')fun2()fun3()fun5()objgraphobjgraph是一个实用模块, 可以列出当前内存中存在的对象, 可用于定位内存泄露推荐文章: http://python.jobbole.com/88827/详情还是谷歌或百度一下, 日后看了再补充]]></content>
      <categories>
        <category>Python</category>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python timeti模块使用]]></title>
    <url>%2Fposts%2F6218c1b6.html</url>
    <content type="text"><![CDATA[前言python可以使用timeit模块来测试小段代码的运行时间.timeit主要的函数有timeit和repeat (还有default_timer, 用法可见文章)timeit和repeat的实现123456789def timeit(stmt="pass", setup="pass", timer=default_timer, number=default_number, globals=None): """Convenience function to create Timer object and call timeit method.""" return Timer(stmt, setup, timer, globals).timeit(number)def repeat(stmt="pass", setup="pass", timer=default_timer, repeat=default_repeat, number=default_number, globals=None): """Convenience function to create Timer object and call repeat method.""" return Timer(stmt, setup, timer, globals).repeat(repeat, number)在上面的代码中可见, 无论是timeit还是repeat都是先 生成Timer对象, 然后调用了Timer对象的timeit或repeat函数。¶参数stmt: 用于传入要测试时间的代码, 可以直接接受字符串的表达式, 也可以接受单个变量, 也可以接受函数。PS: 传入函数时要使用参数setup导入函数 setup: 传入stmt的运行环境, 比如stmt中使用到的参数、变量, 要导入的模块等。可以写一行语句, 也可以写多行语句, 写多行语句时要用**分号;**隔开语句。number: 要测试的代码的运行次数, 默认100000次, 对于耗时的代码, 运行太多次会比较慢, 此时建议自己修改一下运行次数repeat: 指测试要重复几次, 每次的结果构成列表返回, 默认3次。¶用法在使用timeit模块时, 有两种方式直接使用timeit.timeit()、tiemit.repeat()先用timeit.Timer()来生成一个Timer对象, 然后再用Timer对象用timeit()和repeat()函数, 相对灵活一些。¶repeat的优点可以多次重复测试, 并可以对测试所得的执行时间取最小值, 平均值, 最大值, 更方便分析。例子¶例子1测试一个列表推导式 比正常写for循环快多少12345678910111213import timeitfoo = """sum = []for i in range(1000): sum.append(i)"""print(timeit.timeit(stmt="[i for i in range(1000)]", number=100000)) # 传入的是字符串表达式print(timeit.timeit(stmt=foo, number=100000)) # 传入的是变量# 输出：# 3.0182870961591375 # 8.967388768466217¶例子2使用timeit来比较递归斐波那契和迭代斐波那契的时间效率差异¶注意代码中分别定义了两个函数,要测试这两个函数, 需导入这两个函数,即设置setup = from __main__ import recursive_fibonacci,表明从当前运行的代码下导入这两个函数。如果是其他模块的, 则要import别的模块进来1234567891011121314151617181920212223242526272829303132333435363738import timeitdef recursive_fibonacci(nth_item): if nth_item == 1 or nth_item == 2: return 1 elif nth_item &lt;= 0: return 0 return recursive_fibonacci(nth_item - 1) + recursive_fibonacci(nth_item - 2)def loop_fibonacci(nth_item): if nth_item == 1 or nth_item == 2: return 1 elif nth_item &lt;= 0: return 0 first_item, second_item = 1, 1 for x in range(nth_item-2): first_item, second_item = second_item, first_item + second_item return second_itemif __name__ == "__main__": print( timeit.timeit( stmt="recursive_fibonacci(20)", setup="from __main__ import recursive_fibonacci", number=10000 ) ) print( timeit.timeit( stmt="loop_fibonacci(20)", setup="from __main__ import loop_fibonacci", number=10000 ) )¶例子3setup参数的灵活使用, 设置stmt的运行环境的详细例子涉及导入模块变量定义函数调用多行写setup要加分号的方式123456789101112131415161718192021222324252627282930313233343536import timeitx = """say_hi.ParseFromString(p)"""y = """simplejson.loads(x)"""print( timeit.timeit( stmt=x, setup="import say_hi_pb2;" "say_hi = say_hi_pb2.SayHi();" "say_hi.id = 13423;" "say_hi.something = 'axiba';" "say_hi.extra_info = 'xiba';" "p =say_hi.SerializeToString()", number=1000000 ))print( timeit.timeit( stmt=y, setup="import simplejson; " "json=&#123;" "'id': 13423," "'something': 'axiba'," "'extra_info': 'xiba'," "&#125;;" "x = simplejson.dumps(json)", number=1000000 ))命令行调用timeit12345678910python -m timeit [-n N] [-r N] [-s S] [-t] [-c] [-h] [statement...]-n N 执行指定语句的次数-r N 重复测量的次数(默认3次)-s S 指定初始化代码构建环境的导入语句(默认pass)python 3.3新增-t 使用time.time() (不推荐)-c 使用time.clock() (不推荐)-v 打印原始计时结果-h 帮助123456$ python -m timeit '"-".join(str(n) for n in range(100))'loops, best of 3: 40.3 usec per loop$ python -m timeit '"-".join([str(n) for n in range(100)])'loops, best of 3: 33.4 usec per loop$ python -m timeit '"-".join(map(str, range(100)))'loops, best of 3: 25.2 usec per loop]]></content>
      <categories>
        <category>Python</category>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>timeit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 加入评论功能gitalk]]></title>
    <url>%2Fposts%2Fdd07da63.html</url>
    <content type="text"><![CDATA[GitalkGitalk: 一个基于 Github Issue 和 Preact 开发的评论插件详情Demo可见:https://gitalk.github.io/增加评论区¶注册OAuth Application在GitHub上注册新应用, 链接:https://github.com/settings/applications/new参数说明Application name应用名称, 可以任意填入Homepage URL网站URL, 注意用https://开头, 开头如https://vonsdite.cnApplication description应用描述, 可以任意填入Authorization callback URL网站URL, 注意用https://开头, 如https://vonsdite.cn注册后记下Client ID和Client Secret, 后续要使用到¶md5.min.js在themes\next\source\js\src\目录下创建md5.min.js, 并添加如下内容:加这个代码的原因是: 部分文章的评论区会报Error: Validation Failed, 具体原因是由于 Github 限制labels长度不能超过50引起的, 该问题解决方案来自Gitalk项目仓Issues 115, 通过MD5加密ID来缩短labels长度。1!function(n)&#123;"use strict";function t(n,t)&#123;var r=(65535&amp;n)+(65535&amp;t);return(n&gt;&gt;16)+(t&gt;&gt;16)+(r&gt;&gt;16)&lt;&lt;16|65535&amp;r&#125;function r(n,t)&#123;return n&lt;&lt;t|n&gt;&gt;&gt;32-t&#125;function e(n,e,o,u,c,f)&#123;return t(r(t(t(e,n),t(u,f)),c),o)&#125;function o(n,t,r,o,u,c,f)&#123;return e(t&amp;r|~t&amp;o,n,t,u,c,f)&#125;function u(n,t,r,o,u,c,f)&#123;return e(t&amp;o|r&amp;~o,n,t,u,c,f)&#125;function c(n,t,r,o,u,c,f)&#123;return e(t^r^o,n,t,u,c,f)&#125;function f(n,t,r,o,u,c,f)&#123;return e(r^(t|~o),n,t,u,c,f)&#125;function i(n,r)&#123;n[r&gt;&gt;5]|=128&lt;&lt;r%32,n[14+(r+64&gt;&gt;&gt;9&lt;&lt;4)]=r;var e,i,a,d,h,l=1732584193,g=-271733879,v=-1732584194,m=271733878;for(e=0;e&lt;n.length;e+=16)i=l,a=g,d=v,h=m,g=f(g=f(g=f(g=f(g=c(g=c(g=c(g=c(g=u(g=u(g=u(g=u(g=o(g=o(g=o(g=o(g,v=o(v,m=o(m,l=o(l,g,v,m,n[e],7,-680876936),g,v,n[e+1],12,-389564586),l,g,n[e+2],17,606105819),m,l,n[e+3],22,-1044525330),v=o(v,m=o(m,l=o(l,g,v,m,n[e+4],7,-176418897),g,v,n[e+5],12,1200080426),l,g,n[e+6],17,-1473231341),m,l,n[e+7],22,-45705983),v=o(v,m=o(m,l=o(l,g,v,m,n[e+8],7,1770035416),g,v,n[e+9],12,-1958414417),l,g,n[e+10],17,-42063),m,l,n[e+11],22,-1990404162),v=o(v,m=o(m,l=o(l,g,v,m,n[e+12],7,1804603682),g,v,n[e+13],12,-40341101),l,g,n[e+14],17,-1502002290),m,l,n[e+15],22,1236535329),v=u(v,m=u(m,l=u(l,g,v,m,n[e+1],5,-165796510),g,v,n[e+6],9,-1069501632),l,g,n[e+11],14,643717713),m,l,n[e],20,-373897302),v=u(v,m=u(m,l=u(l,g,v,m,n[e+5],5,-701558691),g,v,n[e+10],9,38016083),l,g,n[e+15],14,-660478335),m,l,n[e+4],20,-405537848),v=u(v,m=u(m,l=u(l,g,v,m,n[e+9],5,568446438),g,v,n[e+14],9,-1019803690),l,g,n[e+3],14,-187363961),m,l,n[e+8],20,1163531501),v=u(v,m=u(m,l=u(l,g,v,m,n[e+13],5,-1444681467),g,v,n[e+2],9,-51403784),l,g,n[e+7],14,1735328473),m,l,n[e+12],20,-1926607734),v=c(v,m=c(m,l=c(l,g,v,m,n[e+5],4,-378558),g,v,n[e+8],11,-2022574463),l,g,n[e+11],16,1839030562),m,l,n[e+14],23,-35309556),v=c(v,m=c(m,l=c(l,g,v,m,n[e+1],4,-1530992060),g,v,n[e+4],11,1272893353),l,g,n[e+7],16,-155497632),m,l,n[e+10],23,-1094730640),v=c(v,m=c(m,l=c(l,g,v,m,n[e+13],4,681279174),g,v,n[e],11,-358537222),l,g,n[e+3],16,-722521979),m,l,n[e+6],23,76029189),v=c(v,m=c(m,l=c(l,g,v,m,n[e+9],4,-640364487),g,v,n[e+12],11,-421815835),l,g,n[e+15],16,530742520),m,l,n[e+2],23,-995338651),v=f(v,m=f(m,l=f(l,g,v,m,n[e],6,-198630844),g,v,n[e+7],10,1126891415),l,g,n[e+14],15,-1416354905),m,l,n[e+5],21,-57434055),v=f(v,m=f(m,l=f(l,g,v,m,n[e+12],6,1700485571),g,v,n[e+3],10,-1894986606),l,g,n[e+10],15,-1051523),m,l,n[e+1],21,-2054922799),v=f(v,m=f(m,l=f(l,g,v,m,n[e+8],6,1873313359),g,v,n[e+15],10,-30611744),l,g,n[e+6],15,-1560198380),m,l,n[e+13],21,1309151649),v=f(v,m=f(m,l=f(l,g,v,m,n[e+4],6,-145523070),g,v,n[e+11],10,-1120210379),l,g,n[e+2],15,718787259),m,l,n[e+9],21,-343485551),l=t(l,i),g=t(g,a),v=t(v,d),m=t(m,h);return[l,g,v,m]&#125;function a(n)&#123;var t,r="",e=32*n.length;for(t=0;t&lt;e;t+=8)r+=String.fromCharCode(n[t&gt;&gt;5]&gt;&gt;&gt;t%32&amp;255);return r&#125;function d(n)&#123;var t,r=[];for(r[(n.length&gt;&gt;2)-1]=void 0,t=0;t&lt;r.length;t+=1)r[t]=0;var e=8*n.length;for(t=0;t&lt;e;t+=8)r[t&gt;&gt;5]|=(255&amp;n.charCodeAt(t/8))&lt;&lt;t%32;return r&#125;function h(n)&#123;return a(i(d(n),8*n.length))&#125;function l(n,t)&#123;var r,e,o=d(n),u=[],c=[];for(u[15]=c[15]=void 0,o.length&gt;16&amp;&amp;(o=i(o,8*n.length)),r=0;r&lt;16;r+=1)u[r]=909522486^o[r],c[r]=1549556828^o[r];return e=i(u.concat(d(t)),512+8*t.length),a(i(c.concat(e),640))&#125;function g(n)&#123;var t,r,e="";for(r=0;r&lt;n.length;r+=1)t=n.charCodeAt(r),e+="0123456789abcdef".charAt(t&gt;&gt;&gt;4&amp;15)+"0123456789abcdef".charAt(15&amp;t);return e&#125;function v(n)&#123;return unescape(encodeURIComponent(n))&#125;function m(n)&#123;return h(v(n))&#125;function p(n)&#123;return g(m(n))&#125;function s(n,t)&#123;return l(v(n),v(t))&#125;function C(n,t)&#123;return g(s(n,t))&#125;function A(n,t,r)&#123;return t?r?s(t,n):C(t,n):r?m(n):p(n)&#125;"function"==typeof define&amp;&amp;define.amd?define(function()&#123;return A&#125;):"object"==typeof module&amp;&amp;module.exports?module.exports=A:n.md5=A&#125;(this);¶新建gitalk.swig在站点目录下, themes/next/layout/_third-party/comments/下新建gitalk.swig文件, 并添加如下内容1234567891011121314151617&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/src/md5.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;, clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;, owner: &apos;&#123;&#123; theme.gitalk.githubID &#125;&#125;&apos;, admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;], id: md5(location.pathname), distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos; &#125;) gitalk.render(&apos;gitalk-container&apos;) &lt;/script&gt;&#123;% endif %&#125;¶修改comments.swig修改themes/next/layout/_partials/comments.swig, 添加内容如下, (在倒数第二个endif前):12&#123;% elseif theme.gitalk.enable %&#125; &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;¶修改index.swig修改themes/next/layout/_third-party/comments/index.swig, 在最后一行添加内容:1&#123;% include &apos;gitalk.swig&apos; %&#125;¶新建gitalk.styl在themes/next/source/css/_common/components/third-party/目录下新建gitalk.styl, 并添加如下内容:1234.gt-header a, .gt-comments a, .gt-popup a border-bottom: none;.gt-container .gt-popup .gt-action.is--active:before top: 0.7em;¶修改third-party.styl修改themes/next/source/css/_common/components/third-party/third-party.styl, 在最后一行上添加内容:1@import "gitalk";¶修改主题配置文件_config.yml在主题配置文件themes/next/_config.yml中添加如下内容:12345678gitalk: enable: true githubID: github帐号 # 例：vonsdite 注意必须小写 repo: 仓库名称 # 例：vonsdite.github.io ClientID: Client ID # 上文注册 OAuth Application后得到的值 ClientSecret: Client Secret # 上文注册 OAuth Application后得到的值 adminUser: github帐号 # 指定可初始化评论账户, 例：vonsdite 注意必须小写 distractionFreeMode: true以上就是Next中添加gitalk评论的配置。¶开启评论博客上传到GitHub上后, 打开页面进入某一篇文章此时会看到如下如果上述配置均无误, 点击使用GitHub登录就会建立一个评论区(实际上是在你的Github博客仓库下开了一个Issue)注意如果你某一篇文章不想有评论功能, 你可以在文章的font-matter中加入 comments: false因为加入了评论功能, 在标签、分类页面都会有个评论区, 所以应到相应页面的index.md的font-matter中加入 comments: false并修改站点目录下scaffolds的page.md模板, 因为创建page都会使用到该模板, 而页面不需要有评论区123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;type: comments: false---]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>gitalk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next主题的TOC设置成不是逐级展开]]></title>
    <url>%2Fposts%2F6c0dbfd2.html</url>
    <content type="text"><![CDATA[前言使用Hexo + Next 主题编写文章时, Next主题会自动给文章生成TOC目录, 如图只有当你下拉浏览到相应的目录级时, TOC目录才会展开, 这不方便别人一次性看到所有的目录如果想最开始打开文章一次性就把TOC目录全部展开, 可进行如下的修改打开站点目录下的themes/next/source/css/_common/components/sidebar/sidebar-toc.styl找到如下的代码1.post-toc .nav .nav-child &#123; display: none; &#125;修改为1.post-toc .nav .nav-child &#123; display: block; &#125;这样既可完成想要的功能]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 代码运行计时函数比较]]></title>
    <url>%2Fposts%2F605d5daa.html</url>
    <content type="text"><![CDATA[计时函数计算python某个程序或者代码块的运行时间, 可以使用如下方法方法说明datetime.datetime.now()该方法包含了其他程序使用CPU的时间, 不推荐time.time()Unix系统下, 建议使用time.clock()Windows系统下, 建议使用timeit.default_timer()跨平台使用, 最推荐time.clock()返回的是处理器时间, 而因为Unix中jiffy的缘故, 所以精度不会太高究竟是使用time.clock(), 还是使用time.time(), 由平台来决定总概来讲, 在Unix系统中, 建议使用time.time(),在Windows系统中, 建议使用time.clock().要实现跨平台的精度性, 使用timeit来代替time.¶1.datetime.datetime.now该方法包含了其他程序使用CPU的时间不推荐12345def test_datetime(): start = datetime.datetime.now() time.sleep(100) end = datetime.datetime.now() print("test datetime():", "%fms" % (float((end - start).microseconds) / 1000))¶2.time.time该方法包含了其他程序使用CPU的时间, 返回值是浮点数Unix系统下推荐12345def test_time(): start = time.time() time.sleep(100) end = time.time() print("test time():", "%fms" % ((end - start) * 1000))¶3.time.clock只计算程序运行CPU的时间Windows系统下推荐12345def test_clock(): start = time.clock() time.sleep(100) end = time.clock() print("test clock():", "%fms" % ((end - start) * 1000))¶4.timeit.default_timer实现跨平台的精度性12345def test_timeit(): start = timeit.default_timer() time.sleep(100) end = timeit.default_timer() print("test timeit():", "%fms" % ((end - start) * 1000))¶测试代码结果如图:1234567891011121314151617181920212223242526272829303132333435import timeimport timeitimport datetimeSLEEP_TIME = 0.001def test_datetime(): start = datetime.datetime.now() time.sleep(SLEEP_TIME) end = datetime.datetime.now() print("test datetime():", "%fms" % (float((end - start).microseconds) / 1000))def test_time(): start = time.time() time.sleep(SLEEP_TIME) end = time.time() print("test time():", "%fms" % ((end - start) * 1000))def test_clock(): start = time.clock() time.sleep(SLEEP_TIME) end = time.clock() print("test clock():", "%fms" % ((end - start) * 1000))def test_timeit(): start = timeit.default_timer() time.sleep(SLEEP_TIME) end = timeit.default_timer() print("test timeit():", "%fms" % ((end - start) * 1000)) if __name__ == "__main__": test_datetime() test_time() test_clock() test_timeit()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ATL MFC的CThreadPool]]></title>
    <url>%2Fposts%2F2182c76b.html</url>
    <content type="text"><![CDATA[CThreadPoolMFC提供了一个叫做CThreadPool 的类，这是一个模板类，基于完成端口开发的一个线程池。¶以下是CThreadPool的使用介绍主要的伪代码如下线程池要操作的任务通过实现CTaskBase的DoTask函数来完成12345678910111213141516171819202122232425262728293031323334353637383940#include "CWorker.h" // 包含头文件#define THREADPOOL_SIZE 5// 实例化线程池对象，CWorker是自己定义的Worker类， MSDN中定义了它的原型，它必须包含下面// 所列的几个函数Initialize,Execute,Terminate；具体Worker定义见下面代码CThreadPool&lt;CWorker&gt; threadPool; threadPool.Initialize(NULL, THREADPOOL_SIZE); // 初始化线程池CTaskBase *pTask = NULL;pTask = new CTask(); // 创建任务threadPool.QueueRequest((CParseWorker::RequestType) pTask); // 执行线程池任务/*CThreadPool 调用Initialize，调用此方法来初始化线程池。HRESULT Initialize( void* pvWorkerParam = NULL, int nNumThreads = 0, DWORD dwStackSize = 0, HANDLE hCompletion = INVALID_HANDLE_VALUE) throw();参数pvWorkerParam辅助参数传递给辅助线程对象Initialize， Execute，和Terminate方法。nNumThreads请求的池中的线程数。如果nNumThreads是负数，其绝对值的数值将乘以中要获取的线程总数的计算机的处理器数。如果nNumThreads为零，ATLS_DEFAULT_THREADSPERPROC 将乘以中要获取的线程总数的计算机的处理器数。 默认值为每个处理器的 2 个线程。 如有必要，可以包括 atlutil.h 之前定义此符号自己正整数值。dwStackSize在池中每个线程堆栈大小。hCompletion若要将与完成端口相关联的对象的句柄。返回值返回成功，则为 S_OK 或失败时的错误 HRESULT。*/CWoker.h展开代码12345678910111213141516171819202122232425262728293031323334353637#pragma once#include &lt;atlutil.h&gt;class CTaskBase;class CTask;class CWorker&#123;public: typedef DWORD_PTR RequestType; CWorker(); virtual BOOL Initialize(void *pvParam); virtual void Terminate(void* /*pvParam*/); void Execute(RequestType dw, void *pvParam, OVERLAPPED* pOverlapped) throw(); virtual BOOL GetWorkerData(DWORD /*dwParam*/, void ** /*ppvData*/);protected: DWORD m_dwExecs; LONG m_lId;&#125;; // CWorkerclass CTaskBase&#123;public: virtual void DoTask(void *pvParam, OVERLAPPED *pOverlapped)=0;&#125;;class CTask : public CTaskBase&#123;public: void DoTask(void *pvParam, OVERLAPPED *pOverlapped);&#125;;CWorker.cpp展开代码1234567891011121314151617181920212223242526272829303132333435#include "CWorker.h"LONG g_lCurrId = -1;void CTask::DoTask(void *pvParam, OVERLAPPED *pOverlapped)&#123; &#125;CWorker::CWorker() : m_dwExecs( 0 )&#123; m_lId = InterlockedIncrement( &amp;g_lCurrId );&#125;BOOL CWorker::Initialize(void *pvParam)&#123; return TRUE;&#125;void CWorker::Terminate(void* /*pvParam*/)&#123;&#125;void CWorker::Execute(RequestType dw, void *pvParam, OVERLAPPED* pOverlapped) throw()&#123; CTaskBase* pTask = (CTaskBase*)(DWORD_PTR)dw; pTask-&gt;DoTask(pvParam, pOverlapped); m_dwExecs++; delete pTask;&#125;BOOL CWorker::GetWorkerData(DWORD /*dwParam*/, void ** /*ppvData*/)&#123; return FALSE;&#125;]]></content>
      <categories>
        <category>C/C++</category>
        <category>MFC</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++ 各种计时函数比较]]></title>
    <url>%2Fposts%2F18ab89cc.html</url>
    <content type="text"><![CDATA[前言目前有各种计时函数,一般的处理都是先调用计时函数, 记下当前时间start然后运行自己的代码再调用计时函数, 记下处理后的时间end再end和start做差, 就可以得到程序的执行时间但是各种计时函数的精度不一样.序号函数类型精度级别时间1timeC系统调用低&lt;1s2clcok windows, linux均可用, 推荐C系统调用低&lt;10ms3timeGetTimeWindows API中&lt;1ms4QueryPerformanceCounter windows下最好的方法Windows API高&lt;0.1ms5GetTickCountWindows API中&lt;1ms6RDTSC (实际不可用)指令高&lt;0.1ms7gettimeofday linux下最好的方法linux环境下C系统调用高&lt;0.1mstimetime()获取当前的系统时间, 返回的结果是一个time_t类型, 其值表示从&quot;CUT(Coordinated Universal Time)时间1970年1月1日00:00:00(称为UNIX系统的Epoch时间)&quot;到&quot;当前时刻的秒数&quot;.精度: 低, &lt;1s调用Sleep(50), 让程序暂停50ms, 测得运行时间为 0ms, 表明精度的低12345678910111213#include &lt;time.h&gt;#define SLEEP_TIME 50// test time()void TestTime()&#123; time_t start, end; start = time(NULL); Sleep(50); end = time(NULL); cout &lt;&lt; "Sleep(" &lt;&lt; SLEEP_TIME &lt;&lt; ") :" &lt;&lt; endl; cout &lt;&lt; "Test time(): " &lt;&lt; (end - start) * 1000 &lt;&lt; "ms" &lt;&lt; endl;&#125;clockclock()函数返回从&quot;开启这个程序进程&quot;到&quot;程序中调用clock()函数&quot;时之间的CPU时钟计时单元(clock tick)数, 在MSDN中称之为挂钟时间(wal-clock)常量CLOCKS_PER_SEC, 它用来表示一秒钟会有多少个时钟计时单元精度: 低, &lt;10ms12345678910111213#include &lt;time.h&gt;#define SLEEP_TIME 50// test clock()void TestClock()&#123; clock_t start, end; start = clock(); Sleep(50); end = clock(); cout &lt;&lt; "Sleep(" &lt;&lt; SLEEP_TIME &lt;&lt; ") :" &lt;&lt; endl; cout &lt;&lt; fixed &lt;&lt; setprecision(17) &lt;&lt; "Test clock(): " &lt;&lt; ((double)end - start) / CLOCKS_PER_SEC * 1000 &lt;&lt; "ms" &lt;&lt; endl;&#125;timeGetTimetimeGetTime()函数以毫秒级的系统时间. 该时间为从系统开启算起所经过的时间, 是windows api精度: 中, &lt;1ms1234567891011121314#include &lt;windows.h&gt;#define SLEEP_TIME 50#pragma comment( lib,"winmm.lib" )// test timeGetTime()void TestTimeGetTime()&#123; DWORD start, end; start = timeGetTime(); Sleep(50); end = timeGetTime(); cout &lt;&lt; "Sleep(" &lt;&lt; SLEEP_TIME &lt;&lt; ") :" &lt;&lt; endl; cout &lt;&lt; fixed &lt;&lt; setprecision(17) &lt;&lt; "Test timeGetTime(): " &lt;&lt; ((double)end - start) / 1000 * 1000 &lt;&lt; "ms" &lt;&lt; endl;&#125;QueryPerformanceCounterQueryPerformanceCounter()这个函数返回高精确度性能计数器的值, 它可以以微秒为单位计时. 但是QueryPerformanceCounter()确切的精确计时的最小单位是与系统有关的, 所以, 必须要查询系统以得到QueryPerformanceCounter()返回的嘀哒声的频率. QueryPerformanceFrequency()提供了这个频率值, 返回每秒嘀哒声的个数.精度: 高, &lt;0.1ms1234567891011121314#include &lt;windows.h&gt;#define SLEEP_TIME 50// test QueryPerformanceCounter()void TestQueryPerformanceCounter()&#123; LARGE_INTEGER start, end, tc; QueryPerformanceFrequency(&amp;tc); QueryPerformanceCounter(&amp;start); Sleep(50); QueryPerformanceCounter(&amp;end); cout &lt;&lt; "Sleep(" &lt;&lt; SLEEP_TIME &lt;&lt; ") :" &lt;&lt; endl; cout &lt;&lt; fixed &lt;&lt; setprecision(17) &lt;&lt; "Test QueryPerformanceCounter(): " &lt;&lt; ((double)end.QuadPart - start.QuadPart) / tc.QuadPart * 1000 &lt;&lt; "ms" &lt;&lt; endl;&#125;GetTickCountGetTickCount()返回(retrieve)从操作系统启动到现在所经过(elapsed)的毫秒数, 它的返回值是DWORD精度: 中, &lt;1ms12345678910111213#include &lt;windows.h&gt;#define SLEEP_TIME 50// test GetTickCount()void TestGetTickCount()&#123; DWORD start, end; start = GetTickCount(); Sleep(50); end = GetTickCount(); cout &lt;&lt; "Sleep(" &lt;&lt; SLEEP_TIME &lt;&lt; ") :" &lt;&lt; endl; cout &lt;&lt; fixed &lt;&lt; setprecision(17) &lt;&lt; "Test GetTickCount(): " &lt;&lt; ((double)end - start) / 1000 * 1000 &lt;&lt; "ms" &lt;&lt; endl;&#125;RDTSCRDTSC指令, 在Intel Pentium以上级别的CPU中, 有一个称为&quot;时间戳(Time Stamp)&quot;的部件, 它以64位无符号整型数的格式, 记录了自CPU上电以来所经过的时钟周期数。由于目前的CPU主频都非常高, 因此这个部件可以达到纳秒级的计时精度。这个精确性是上述几种方法所无法比拟的. 在Pentium以上的CPU中, 提供了一条机器指令RDTSC(Read Time Stamp Counter)来读取这个时间戳的数字, 并将其保存在EDX:EAX寄存器对中. 由于EDX:EAX寄存器对恰好是Win32平台下C语言保存函数返回值的寄存器, 所以我们可以把这条指令看成是一个普通的函数调用, 因为RDTSC不被C的内嵌汇编器直接支持, 所以我们要用_emit伪指令直接嵌入该指令的机器码形式0X0F、0X31¶然而真相多核时代不宜再用 x86 的 RDTSC 指令测试指令周期和时间不能保证同一块主板上每个核的 TSC 是同步的；CPU 的时钟频率可能变化, 例如笔记本电脑的节能功能；乱序执行导致 RDTSC 测得的周期数不准, 这个问题从 Pentium Pro 时代就存在。123456789101112131415161718192021222324252627#define SLEEP_TIME 50// test RDTSC// 多核时代不宜再用 x86 的 RDTSC 指令测试指令周期和时间// 1. 不能保证同一块主板上每个核的 TSC 是同步的；// 2. CPU 的时钟频率可能变化, 例如笔记本电脑的节能功能；// 3. 乱序执行导致 RDTSC 测得的周期数不准, 这个问题从 Pentium Pro 时代就存在。inline unsigned __int64 GetCycleCount()&#123; __asm &#123; _emit 0x3F; _emit 0x31; &#125;&#125;// 我的CPU频率#define FREQUENCY (2.6*(1&lt;&lt;30)) void TestRDTSC()&#123; unsigned __int64 start, end; start = GetCycleCount(); Sleep(50); end = GetCycleCount(); cout &lt;&lt; "Sleep(" &lt;&lt; SLEEP_TIME &lt;&lt; ") :" &lt;&lt; endl; cout &lt;&lt; fixed &lt;&lt; setprecision(17) &lt;&lt; "Test RDTSC(): " &lt;&lt; ((double)end - start) / FREQUENCY * 1000 &lt;&lt; "ms" &lt;&lt; endl;&#125;gettimeofdaygettimeofday() linux环境下的计时函数, int gettimeofday(struct timeval* tv , struct timezone* tz), gettimeofday()会把目前的时间有tv所指的结构返回, 当地时区的信息则放到tz所指的结构中.精度: 高, &lt;0.1ms123456789101112131415161718192021222324252627#define SLEEP_TIME 50// test gettimeofday()// timeval结构定义为:struct timeval &#123; long tv_sec; // 秒 long tv_usec; // 微秒&#125;;//timezone 结构定义为:struct timezone &#123; int tz_minuteswest; // 和Greenwich 时间差了多少分钟 int tz_dsttime; // 日光节约时间的状态&#125;;void TestGetTimeOfDay()&#123; timeval start, end; double timeuse; gettimeofday(&amp;start, NULL); Sleep(50); gettimefoday(&amp;end, NULL); timeuse = end.tv_sec - start.tv_sec + (end.tv_usec - start.tv_usec) / 50000.0; cout &lt;&lt; "Sleep(" &lt;&lt; SLEEP_TIME &lt;&lt; ") :" &lt;&lt; endl; cout &lt;&lt; fixed &lt;&lt; setprecision(17) &lt;&lt; "Test gettimeofday(): " &lt;&lt; timeuse * 1000 &lt;&lt; "ms" &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows计算目录大小 递归和线程池两种实现]]></title>
    <url>%2Fposts%2F62aadf3b.html</url>
    <content type="text"><![CDATA[前言windows下文件夹目录大小没有直接获取的方法，一般直接使用递归的方式来计算，或者使用多线程提高并发度计算。以下举的例子是计算目标目录大小以及目标目录下所有子目录大小的例子, 不是计算单一目录大小的例子ThreadPool.h的实现来源于: https://github.com/log4cplus/Threadpool效果比较PS: 输出的上部分是递归方式, 下部分是线程池方式线程池的池大小为1时, 耗时略多于普通递归(因为线程的一些额外开销)池的大小适当增大, 可以有效的提高效率(但池过于大, 也会造成效率降低)实现的代码ThreadPool.h展开代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268// -*- C++ -*-// Copyright (c) 2012-2015 Jakob Progsch//// This software is provided 'as-is', without any express or implied// warranty. In no event will the authors be held liable for any damages// arising from the use of this software.//// Permission is granted to anyone to use this software for any purpose,// including commercial applications, and to alter it and redistribute it// freely, subject to the following restrictions://// 1. The origin of this software must not be misrepresented; you must not// claim that you wrote the original software. If you use this software// in a product, an acknowledgment in the product documentation would be// appreciated but is not required.//// 2. Altered source versions must be plainly marked as such, and must not be// misrepresented as being the original software.//// 3. This notice may not be removed or altered from any source// distribution.//// Modified for log4cplus, copyright (c) 2014-2015 Václav Zeman.#ifndef THREAD_POOL_H_7ea1ee6b_4f17_4c09_b76b_3d44e102400c#define THREAD_POOL_H_7ea1ee6b_4f17_4c09_b76b_3d44e102400c#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;memory&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;future&gt;#include &lt;atomic&gt;#include &lt;functional&gt;#include &lt;stdexcept&gt;#include &lt;algorithm&gt;#include &lt;cassert&gt;class ThreadPool &#123;public: explicit ThreadPool(std::size_t threads = (std::max)(2u, std::thread::hardware_concurrency())); template&lt;class F, class... Args&gt; auto enqueue(F&amp;&amp; f, Args&amp;&amp;... args) -&gt;std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt;; void wait_until_empty(); void wait_until_nothing_in_flight(); void set_queue_size_limit(std::size_t limit); void set_pool_size(std::size_t limit); ~ThreadPool();private: void emplace_back_worker(std::size_t worker_number); // need to keep track of threads so we can join them std::vector&lt; std::thread &gt; workers; // target pool size std::size_t pool_size; // the task queue std::queue&lt; std::function&lt;void()&gt; &gt; tasks; // queue length limit std::size_t max_queue_size = 100000; // stop signal bool stop = false; // synchronization std::mutex queue_mutex; std::condition_variable condition_producers; std::condition_variable condition_consumers; std::mutex in_flight_mutex; std::condition_variable in_flight_condition; std::atomic&lt;std::size_t&gt; in_flight; struct handle_in_flight_decrement &#123; ThreadPool &amp; tp; handle_in_flight_decrement(ThreadPool &amp; tp_) : tp(tp_) &#123; &#125; ~handle_in_flight_decrement() &#123; std::size_t prev = std::atomic_fetch_sub_explicit(&amp;tp.in_flight, std::size_t(1), std::memory_order_acq_rel); if (prev == 1) &#123; std::unique_lock&lt;std::mutex&gt; guard(tp.in_flight_mutex); tp.in_flight_condition.notify_all(); &#125; &#125; &#125;;&#125;;// the constructor just launches some amount of workersinline ThreadPool::ThreadPool(std::size_t threads) : pool_size(threads) , in_flight(0)&#123; for (std::size_t i = 0; i != threads; ++i) emplace_back_worker(i);&#125;// add new work item to the pooltemplate&lt;class F, class... Args&gt;auto ThreadPool::enqueue(F&amp;&amp; f, Args&amp;&amp;... args) -&gt; std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt;&#123; using return_type = typename std::result_of&lt;F(Args...)&gt;::type; auto task = std::make_shared&lt; std::packaged_task&lt;return_type()&gt; &gt;( std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...) ); std::future&lt;return_type&gt; res = task-&gt;get_future(); std::unique_lock&lt;std::mutex&gt; lock(queue_mutex); if (tasks.size() &gt;= max_queue_size) // wait for the queue to empty or be stopped condition_producers.wait(lock, [this] &#123; return tasks.size() &lt; max_queue_size || stop; &#125;); // don't allow enqueueing after stopping the pool if (stop) throw std::runtime_error("enqueue on stopped ThreadPool"); tasks.emplace([task]() &#123; (*task)(); &#125;); std::atomic_fetch_add_explicit(&amp;in_flight, std::size_t(1), std::memory_order_relaxed); condition_consumers.notify_one(); return res;&#125;// the destructor joins all threadsinline ThreadPool::~ThreadPool()&#123; std::unique_lock&lt;std::mutex&gt; lock(queue_mutex); stop = true; condition_consumers.notify_all(); condition_producers.notify_all(); pool_size = 0; condition_consumers.wait(lock, [this] &#123; return this-&gt;workers.empty(); &#125;); assert(in_flight == 0);&#125;inline void ThreadPool::wait_until_empty()&#123; std::unique_lock&lt;std::mutex&gt; lock(this-&gt;queue_mutex); this-&gt;condition_producers.wait(lock, [this] &#123; return this-&gt;tasks.empty(); &#125;);&#125;inline void ThreadPool::wait_until_nothing_in_flight()&#123; std::unique_lock&lt;std::mutex&gt; lock(this-&gt;in_flight_mutex); this-&gt;in_flight_condition.wait(lock, [this] &#123; return this-&gt;in_flight == 0; &#125;);&#125;inline void ThreadPool::set_queue_size_limit(std::size_t limit)&#123; std::unique_lock&lt;std::mutex&gt; lock(this-&gt;queue_mutex); if (stop) return; std::size_t const old_limit = max_queue_size; max_queue_size = (std::max)(limit, std::size_t(1)); if (old_limit &lt; max_queue_size) condition_producers.notify_all();&#125;inline void ThreadPool::set_pool_size(std::size_t limit)&#123; if (limit &lt; 1) limit = 1; std::unique_lock&lt;std::mutex&gt; lock(this-&gt;queue_mutex); if (stop) return; pool_size = limit; std::size_t const old_size = this-&gt;workers.size(); if (pool_size &gt; old_size) &#123; // create new worker threads for (std::size_t i = old_size; i != pool_size; ++i) emplace_back_worker(i); &#125; else if (pool_size &lt; old_size) // notify all worker threads to start downsizing this-&gt;condition_consumers.notify_all();&#125;inline void ThreadPool::emplace_back_worker(std::size_t worker_number)&#123; workers.emplace_back( [this, worker_number] &#123; for (;;) &#123; std::function&lt;void()&gt; task; bool notify; &#123; std::unique_lock&lt;std::mutex&gt; lock(this-&gt;queue_mutex); this-&gt;condition_consumers.wait(lock, [this, worker_number] &#123; return this-&gt;stop || !this-&gt;tasks.empty() || pool_size &lt; worker_number + 1; &#125;); // deal with downsizing of thread pool or shutdown if ((this-&gt;stop &amp;&amp; this-&gt;tasks.empty()) || (!this-&gt;stop &amp;&amp; pool_size &lt; worker_number + 1)) &#123; std::thread &amp; last_thread = this-&gt;workers.back(); std::thread::id this_id = std::this_thread::get_id(); if (this_id == last_thread.get_id()) &#123; // highest number thread exits, resizes the workers // vector, and notifies others last_thread.detach(); this-&gt;workers.pop_back(); this-&gt;condition_consumers.notify_all(); return; &#125; else continue; &#125; else if (!this-&gt;tasks.empty()) &#123; task = std::move(this-&gt;tasks.front()); this-&gt;tasks.pop(); notify = this-&gt;tasks.size() + 1 == max_queue_size || this-&gt;tasks.empty(); &#125; else continue; &#125; handle_in_flight_decrement guard(*this); if (notify) &#123; std::unique_lock&lt;std::mutex&gt; lock(this-&gt;queue_mutex); condition_producers.notify_all(); &#125; task(); &#125; &#125; );&#125;#endif // THREAD_POOL_H_7ea1ee6b_4f17_4c09_b76b_3d44e102400cGetDirectorySize.cpp展开代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;unordered_map&gt;#include &lt;mutex&gt;#include &lt;windows.h&gt;#include &lt;time.h&gt;#include "ThreadPool.h"using namespace std;#ifdef UNICODEtypedef wstring tstring;#elsetypedef string tstring;#endif#define POOL_SIZE 1000unordered_map&lt;tstring, ULONGLONG&gt; mapDirSize_simple; // 递归的map表unordered_map&lt;tstring, ULONGLONG&gt; mapDirSize; // 线程池的map表std::mutex mtx;ThreadPool pool(POOL_SIZE);// 根据文件的高32位和低32位求出文件的大小ULONGLONG GetFileSize(ULONGLONG high, ULONGLONG low)&#123; return ((high &lt;&lt; 32) | low);&#125;// 去掉中所有的 "/" "\" ":" tstring ClearPathFormat(tstring path)&#123; size_t pos = 0; tstring clear1 = TEXT("/"); tstring clear2 = TEXT("\\"); tstring clear3 = TEXT(":"); while ((pos = path.find(clear1)) != tstring::npos) &#123; path.replace(pos, clear1.length(), ""); &#125; while ((pos = path.find(clear2)) != tstring::npos) &#123; path.replace(pos, clear2.length(), ""); &#125; while ((pos = path.find(clear3)) != tstring::npos) &#123; path.replace(pos, clear3.length(), ""); &#125; return path;&#125;// 简单递归得目录大小ULONGLONG SimpleGetDirectorySize(vector&lt;tstring&gt; vecParentPath, tstring lpDirName)&#123; ULONGLONG nDirSize = 0; // 文件夹大小 tstring strDirName = lpDirName; strDirName += TEXT("/*.*"); // 目录名字 HANDLE hFile; WIN32_FIND_DATA pNextInfo; hFile = FindFirstFile(strDirName.c_str(), &amp;pNextInfo); if (INVALID_HANDLE_VALUE == hFile) return 0; vector&lt;tstring&gt; copyVecParent = vecParentPath; copyVecParent.push_back(ClearPathFormat(lpDirName)); while (FindNextFile(hFile, &amp;pNextInfo)) &#123; // 跳过 "." ".." 两个目录 if (!strcmp(pNextInfo.cFileName, ".") || !strcmp(pNextInfo.cFileName, "..")) continue; if (pNextInfo.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) &#123; // 目录, 递归下去加 tstring strTmp = lpDirName; strTmp += TEXT("/"); strTmp += pNextInfo.cFileName; SimpleGetDirectorySize(copyVecParent, strTmp.c_str()); &#125; else &#123; // 文件 nDirSize += GetFileSize(pNextInfo.nFileSizeHigh, pNextInfo.nFileSizeLow); &#125; &#125; if (nDirSize) &#123; mapDirSize_simple[ClearPathFormat(lpDirName)] += nDirSize; for (auto parent : vecParentPath) &#123; mapDirSize_simple[parent] += nDirSize; &#125; &#125; return mapDirSize_simple[ClearPathFormat(lpDirName)];&#125;// 计算目录大小void CalcDirectoySize(vector&lt;tstring&gt; vecParentPath, tstring strOwnPath)&#123; ULONGLONG nCurrentSize = 0; tstring strDirName = strOwnPath; strDirName += TEXT("/*.*"); // 目录名字 HANDLE hFile; WIN32_FIND_DATA pNextInfo; hFile = FindFirstFile(strDirName.c_str(), &amp;pNextInfo); if (INVALID_HANDLE_VALUE == hFile) return ; vector&lt;tstring&gt; copyVecParent = vecParentPath; copyVecParent.push_back(ClearPathFormat(strOwnPath)); while (FindNextFile(hFile, &amp;pNextInfo)) &#123; // 跳过 "." ".." 两个目录 if (!strcmp(pNextInfo.cFileName, ".") || !strcmp(pNextInfo.cFileName, "..")) continue; if (pNextInfo.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) &#123; // 目录 tstring strTmp = strOwnPath; strTmp += TEXT("/"); strTmp += pNextInfo.cFileName; mtx.lock(); pool.enqueue(CalcDirectoySize, copyVecParent, strTmp); mtx.unlock(); &#125; else &#123; // 文件 nCurrentSize += GetFileSize(pNextInfo.nFileSizeHigh, pNextInfo.nFileSizeLow); &#125; &#125; if (nCurrentSize) &#123; mtx.lock(); mapDirSize[ClearPathFormat(strOwnPath)] += nCurrentSize; for (auto parent : vecParentPath) &#123; mapDirSize[parent] += nCurrentSize; &#125; mtx.unlock(); &#125;&#125;void GetDirectorySize(tstring strDirName)&#123; vector&lt;tstring&gt; vecEmpty; mtx.lock(); pool.enqueue(CalcDirectoySize, vecEmpty, strDirName); mtx.unlock();&#125;int main()&#123; tstring strDirName = TEXT("c:\\Windows"); LARGE_INTEGER t1, t2, tc; // 递归计算目录大小 QueryPerformanceFrequency(&amp;tc); QueryPerformanceCounter(&amp;t1); vector&lt;tstring&gt; vecEmpty; cout &lt;&lt; strDirName &lt;&lt; " size: "&lt;&lt; (double)SimpleGetDirectorySize(vecEmpty, strDirName.c_str()) / (1 &lt;&lt; 30) &lt;&lt; "GB" &lt;&lt; endl; QueryPerformanceCounter(&amp;t2); printf("Use Time:%fs\n", (t2.QuadPart - t1.QuadPart)*1.0 / tc.QuadPart); // 使用线程池计算目录大小 QueryPerformanceFrequency(&amp;tc); QueryPerformanceCounter(&amp;t1); GetDirectorySize(strDirName); pool.wait_until_nothing_in_flight(); cout &lt;&lt; strDirName &lt;&lt; " size: " &lt;&lt; (double)mapDirSize[ClearPathFormat(strDirName)] / (1 &lt;&lt; 30) &lt;&lt; "GB" &lt;&lt; "\t-&gt; with pool size: " &lt;&lt; POOL_SIZE &lt;&lt; endl; QueryPerformanceCounter(&amp;t2); printf("Use Time:%fs\n", (t2.QuadPart - t1.QuadPart)*1.0 / tc.QuadPart); return 0;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js使用xpath和selector定位元素]]></title>
    <url>%2Fposts%2Fcb216d2c.html</url>
    <content type="text"><![CDATA[Js根据xpath定位元素12345678910function find_element_by_xpath(STR_XPATH) &#123; var xresult = document.evaluate(STR_XPATH, document, null, XPathResult.ANY_TYPE, null); var xnodes = []; var xres; while (xres = xresult.iterateNext()) &#123; xnodes.push(xres); &#125; return xnodes;&#125;使用selector定位元素querySelector和querySelectorAll方法是W3C Selectors API规范中定义的。他们的作用是根据CSS 选择器规范，便捷定位文档中指定元素。目前几乎主流浏览器均支持了他们。包括 IE8(含) 以上版本、 Firefox、 Chrome、Safari、Opera。querySelector 和 querySelectorAll 在规范中定义了如下接口：123456789module dom &#123; [Supplemental, NoInterfaceObject] interface NodeSelector &#123; Element querySelector( in DOMString selectors); NodeList querySelectorAll( in DOMString selectors); &#125;; Document implements NodeSelector; DocumentFragment implements NodeSelector; Element implements NodeSelector; &#125;;从接口定义可以看到Document、DocumentFragment、Element都实现了NodeSelector接口。即这三种类型的元素都拥有者两个方法。querySelector和querySelectorAll的参数须是符合css selector的字符串。不同的是querySelector返回的是一个对象，querySelectorAll返回的一个集合(NodeList)¶例子获取页面属性为test的元素：12345document.getElementById("test");//ordocument.querySelector("#test");//ordocument.querySelectorAll("#test")[0];获取页面class属性为'red'的元素:12345document.getElementsByClassName('red')//ordocument.querySelector('.red')//ordocument.querySelectorAll('.red')]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器/Chrome 在console控制台导入js文件]]></title>
    <url>%2Fposts%2Ff979bc0f.html</url>
    <content type="text"><![CDATA[前言有时候需要在浏览器的console上运行代码, 当需要引入别的js文件时, 就可以如下操作:例子, 比如导入 jquery-1.4.min.js1234var importJs=document.createElement('script');importJs.setAttribute("type","text/javascript");importJs.setAttribute("src", 'http://ajax.microsoft.com/ajax/jquery/jquery-1.4.min.js');document.getElementsByTagName("head")[0].appendChild(importJs);]]></content>
      <categories>
        <category>Javascript</category>
        <category>Console</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next自定义是否显示TOC的自动编号]]></title>
    <url>%2Fposts%2Fc6c725f5.html</url>
    <content type="text"><![CDATA[前言有时候写文章, 我们会习惯性地加上编号, 有时候又不想加上编号, 这个时候就需要自定义是否显示编号了。效果如图:设置进入站点文件夹下themes/next/layout/_macro/sidebar.swig, 找到如下的代码12345&#123;% if page.toc_number === undefined %&#125; &#123;% set toc = toc(page.content, &#123; &quot;class&quot;: &quot;nav&quot;, list_number: theme.toc.number &#125;) %&#125;&#123;% else %&#125; &#123;% set toc = toc(page.content, &#123; &quot;class&quot;: &quot;nav&quot;, list_number: page.toc_number &#125;) %&#125;&#123;% endif %&#125;发现代码的逻辑是：先判断文章的front-matter是否定义了toc_number无则会使用主题配置文件中的toc_number而toc_number是一个布尔值, 表明是否要给文章的toc列表编号所以只要在不需要加编号的文章的front-matter加上 toc_number: false即可]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 添加sitemap优化seo]]></title>
    <url>%2Fposts%2Ff6d1cfff.html</url>
    <content type="text"><![CDATA[添加sitemap¶1. 使用命令行cmd进入站点文件夹¶2. 输入以下两条命令12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save¶3. 在站点配置文件_config.yml加入如下的配置sitemap是给google的站点地图, baidusitemap是给百度的站点地图12345# sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml修改后, 输入命令12hexo ghexo s即可查看到站点地图的信息或者在public中看到sitemap.xml和baidusitemap.xml¶4. 将sitemap提交在google search console提交你的sitemap.xml在百度搜索资源平台-数据引入-链接提交-页面底部自动提交-sitemap提交sitemap地址]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode 常用快捷键]]></title>
    <url>%2Fposts%2F317f5687.html</url>
    <content type="text"><![CDATA[Vscode查看所有的快捷键查看修改过的快捷键Vscode可以查看用户自己修改过的快捷键, 在搜索框键入@source:user即可Vscode常用快捷键按键功能Ctrl + K,Ctrl + C 或 Ctrl + /单行注释Ctrl + K, Ctrl + U取消单行注释Alt + Shift + A多行注释Ctrl + Shift + P或F1显示命令面板 Show Command PaletteCtrl + P快速打开 Quick OpenCtrl + Shift + N新窗口/实例 New window/instanceCtrl + Shift + W关闭窗口/实例 Close window/instanceCtrl + W关闭单个窗口Ctrl + X剪切行（空选定） Cut line (empty selection)Ctrl + C复制行（空选定）Copy line (empty selection)Alt + ↑ / ↓向上/向下移动行 Move line up/downShift + Alt + ↓ / ↑向上/向下复制行 Copy line up/downCtrl + Shift + K删除行 Delete lineCtrl + Enter在下面插入行 Insert line belowCtrl + Shift + Enter在上面插入行 Insert line aboveCtrl + Shift + \跳到匹配的括号 Jump to matching bracketCtrl + ] / [缩进/缩进行 Indent/outdent lineHome转到行首 Go to beginning of lineEnd转到行尾 Go to end of lineCtrl + Home转到文件开头 Go to beginning of fileCtrl + End转到文件末尾 Go to end of fileCtrl + ↑ / ↓向上/向下滚动行 Scroll line up/downAlt + PgUp / PgDown向上/向下滚动页面 Scroll page up/downCtrl + Shift + [折叠（折叠）区域 Fold (collapse) regionCtrl + Shift + ]展开（未折叠）区域 Unfold (uncollapse) regionCtrl + K Ctrl + [折叠（未折叠）所有子区域 Fold (collapse) all subregionsCtrl + K Ctrl + ]展开（未折叠）所有子区域 Unfold (uncollapse) all subregionsCtrl + K Ctrl + 0折叠（折叠）所有区域 Fold (collapse) all regionsCtrl + K Ctrl + J展开（未折叠）所有区域 Unfold (uncollapse) all regionsAlt + Z切换换行 Toggle word wrapCtrl + T显示所有符号 Show all SymbolsCtrl + G转到行… Go to Line…Ctrl + P转到文件… Go to File…Ctrl + Shift + O转到符号… Go to Symbol…Ctrl + Shift + M显示问题面板 Show Problems panelF8转到下一个错误或警告 Go to next error or warningShift + F8转到上一个错误或警告 Go to previous error or warningCtrl + Shift + Tab导航编辑器组历史记录 Navigate editor group historyAlt + ←/→返回/前进 Go back / forwardCtrl + M切换选项卡移动焦点 Toggle Tab moves focusCtrl + F查找 FindCtrl + H替换 ReplaceF3 / Shift + F3查找下一个/上一个 Find next/previousAlt + Enter选择查找匹配的所有出现 Select all occurences of Find matchCtrl + D将选择添加到下一个查找匹配 Add selection to next Find matchCtrl + K Ctrl + D将最后一个选择移至下一个查找匹配项 Move last selection to next Find matchAlt + C / R / W切换区分大小写/正则表达式/整个词 Toggle case-sensitive / regex / whole wordAlt + 单击插入光标 Insert cursorCtrl + Alt + ↑/↓在上/下插入光标 Insert cursor above / belowCtrl + U撤消上一个光标操作 Undo last cursor operationShift + Alt + I在选定的每一行的末尾插入光标 Insert cursor at end of each line selectedCtrl + I选择当前行 Select current lineCtrl + Shift + L选择当前选择的所有出现 Select all occurrences of current selectionCtrl + F2选择当前字的所有出现 Select all occurrences of current wordShift + Alt + →展开选择 Expand selectionShift + Alt + ←缩小选择 Shrink selectionShift + Alt + （拖动鼠标）列（框）选择 Column (box) selectionCtrl + Shift + Alt +（箭头键）列（框）选择 Column (box) selectionCtrl + Shift + Alt + PgUp / PgDown列（框）选择页上/下 Column (box) selection page up/downCtrl + space触发建议 Trigger suggestionCtrl + Shift + Space触发器参数提示 Trigger parameter hintsTabEmmet 展开缩写 Emmet expand abbreviationShift + Alt + F格式化文档 Format documentCtrl + K Ctrl + F格式选定区域 Format selectionF12转到定义 Go to DefinitionAlt + F12Peek定义 Peek DefinitionCtrl + K F12打开定义到边 Open Definition to the sideCtrl + .快速解决 Quick FixShift + F12显示引用 Show ReferencesF2重命名符号 Rename SymbolCtrl + Shift + . /，替换为下一个/上一个值 Replace with next/previous valueCtrl + K Ctrl + X修剪尾随空格 Trim trailing whitespaceCtrl + K M更改文件语言 Change file languageCtrl + F4, Ctrl + W关闭编辑器 Close editorCtrl + K F关闭文件夹 Close folderCtrl + \拆分编辑器 Split editorCtrl + 1 / 2 / 3聚焦到第1，第2或第3编辑器组 Focus into 1st, 2nd or 3rd editor groupCtrl + K Ctrl + ←/→聚焦到上一个/下一个编辑器组 Focus into previous/next editor groupCtrl + Shift + PgUp / PgDown向左/向右移动编辑器 Move editor left/rightCtrl + K ← / →移动活动编辑器组 Move active editor groupCtrl + N新文件 New FileCtrl + O打开文件… Open File…Ctrl + S保存 SaveCtrl + Shift + S另存为… Save As…Ctrl + K S全部保存 Save AllCtrl + F4关闭 CloseCtrl + K Ctrl + W关闭所有 Close AllCtrl + Shift + T重新打开关闭的编辑器 Reopen closed editorCtrl + K输入保持打开 Enter Keep OpenCtrl + Tab打开下一个 Open nextCtrl + Shift + Tab打开上一个 Open previousCtrl + K P复制活动文件的路径 Copy path of active fileCtrl + K R显示资源管理器中的活动文件 Reveal active file in ExplorerCtrl + K O显示新窗口/实例中的活动文件 Show active file in new window/instanceF11切换全屏 Toggle full screenShift + Alt + 1切换编辑器布局 Toggle editor layoutCtrl + = / -放大/缩小 Zoom in/outCtrl + B切换侧栏可见性 Toggle Sidebar visibilityCtrl + Shift + E显示浏览器/切换焦点 Show Explorer / Toggle focusCtrl + Shift + F显示搜索 Show SearchCtrl + Shift + G显示Git Show GitCtrl + Shift + D显示调试 Show DebugCtrl + Shift + X显示扩展 Show ExtensionsCtrl + Shift + H替换文件 Replace in filesCtrl + Shift + J切换搜索详细信息 Toggle Search detailsCtrl + Shift + C打开新命令提示符/终端 Open new command prompt/terminalCtrl + Shift + U显示输出面板 Show Output panelCtrl + Shift + V切换Markdown预览 Toggle Markdown previewCtrl + K V从旁边打开Markdown预览 Open Markdown preview to the sideF9切换断点 Toggle breakpointF5开始/继续 Start/ContinueShift + F5停止 StopF11 / Shift + F11下一步/上一步 Step into/outF10跳过 Step overCtrl + K Ctrl + I显示悬停 Show hover`Ctrl + ``显示集成终端 Show integrated terminal`Ctrl + Shift + ``创建新终端 Create new terminalCtrl + Shift + C复制选定 Copy selectionCtrl + Shift + V粘贴到活动端子 Paste into active terminalCtrl + ↑ / ↓向上/向下滚动 Scroll up/downShift + PgUp / PgDown向上/向下滚动页面 Scroll page up/downCtrl + Home / End滚动到顶部/底部 Scroll to top/bottom]]></content>
      <categories>
        <category>Vscode</category>
      </categories>
      <tags>
        <tag>Vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode python环境配置]]></title>
    <url>%2Fposts%2F8caab64.html</url>
    <content type="text"><![CDATA[前言Vscode Python Windows环境配置安装Vscode安装Vscode插件Python安装Python3配置启动Python项目的工作区, 例如123mkdir hellocd hellocode .¶选择Python解析器按下ctrl+shift+p 调出命令面板, 键入python: select interpreter, 选择该Python项目的Python解析器与在settings.json的工作区中设置python.pythonPath相同1"python.pythonPath": "E:\\python\\python.exe",¶运行Python程序¶配置Python调试器先设置断点点击左侧的调试点击小齿轮设置launch.json(会自动生成launch.json模板, 下拉框选第一个Python: Current File (Integrated Terminal)就好了)如果想在调试的时候, 让程序停在程序运行前, 可以再launch.json中加入stopOnEntry: true12345678&#123; "name": "Python: Current File (Integrated Terminal)", "type": "python", "request": "launch", "program": "$&#123;file&#125;", "console": "integratedTerminal", "stopOnEntry": true&#125;,然后按f5即可进行调试(可以单步调试等等, 更多细节可以看 python调试)¶安装lintingLinting突出了Python源代码中的语法和风格错误先使用命令行, 键入如下命令1pip install pylint然后在工作区的settings.json加入如下12"python.linting.pylintEnabled": true,"python.linting.enabled": true,效果图更多细节查看Linting Python in Visual Studio Code¶单元测试可以使用python内建的unittest, 或者pytest或者nose(自行安装即可)例子:比如使用unittest, 则在工作区的settings.json加入如下:123"python.unitTest.unittestEnabled": true,"python.unitTest.pyTestEnabled": false,"python.unitTest.nosetestsEnabled": false,创建inc_dec.py12345def increment(x): return x + 1def decrement(x): return x - 1创建test1.py123456789101112import unittestimport inc_decclass Test_TestIncrementDecrement(unittest.TestCase): def test_increment(self): self.assertEquals(inc_dec.increment(3), 4) def test_decrement(self): self.assertEquals(inc_dec.decrement(3), 4)if __name__ == '__main__': unittest.main()当使用unittest时, vscode看起来会是这样的(emmm, 单级工作区才能这样看到, 太多文件夹貌似不行…)更多单元测试细节可查看Python unit tests in Visual Studio Code]]></content>
      <categories>
        <category>Vscode</category>
        <category>Python配置</category>
      </categories>
      <tags>
        <tag>Vscode</tag>
        <tag>Vscode Python配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode C/C++编译运行环境搭建]]></title>
    <url>%2Fposts%2F7552b9cf.html</url>
    <content type="text"><![CDATA[前言本文将介绍VscodeC/C++编译运行环境的在Windows下的搭建, 共介绍2种方案推荐使用前两种, 即可完成编译运行调试功能使用Vscode的Tasks功能来编译运行, 并使用GDB调试使用CodeRunner环境配置安装Vscode安装MinGW-w64和ClangLLVM Download Page 在此页面下载Clang:选Pre-Built Binaries中的Clang for Windows (64-bit), 不需要下.sig文件MinGW-w64 - for 32 and 64 bit Windows 在此页面下载MinGW-w64LLVM下载好了以后安装, 添加环境变量时：选Add LLVM to the system PATH for all usersMinGW 安装时, Architecture选x86_64, 装好以后把东西全部复制到Clang的文件夹里去, 它们会无冲突合并。PS:为什么既要装Clang又要装MinGW, 是因为Clang没有头文件。如果你安装了其他IDE需要注意把其他的MinGW从环境变量中去掉; 也可以自己把它们的编译器设为Clang安装Vscode插件通过Vscode的扩展搜索并下载以下两个插件C/C++ (第一个方案需要)Code Runner (第二个方案需要)在settings.json中添加如下的配置:123456789101112131415"editor.formatOnType": true,"editor.snippetSuggestions": "top","C_Cpp.clang_format_sortIncludes": true,"C_Cpp.errorSquiggles": "Disabled","C_Cpp.autocomplete": "Disabled","clang.cflags": [ "--target=x86_64-w64-mingw", "-std=c11", "-Wall"],"clang.cxxflags": [ "--target=x86_64-w64-mingw", "-std=c++17", "-Wall"],方案一¶使用 Vscode 优秀的 Tasks 功能启用编译运行命令打开C或者C/C++的工作区, 使用快捷键ctrl+shift+p, 键入c/cpp: edit configurations, 按Enter打开c_cpp_properties.json将以下的内容覆盖到c_cpp_properties.json中123456789101112131415161718192021222324252627&#123; "configurations": [ &#123; "name": "MinGW", "includePath": [ "$&#123;workspaceFolder&#125;" ], "browse": &#123; "path": [ "$&#123;workspaceFolder&#125;" ], "limitSymbolsToIncludedHeaders": true, "databaseFilename": "" &#125;, "defines": [ "_DEBUG", "UNICODE", "_UNICODE" ], "compilerPath": "E:/LLVM/bin/gcc.exe", "cStandard": "c11", "cppStandard": "c++17", "intelliSenseMode": "clang-x64" &#125; ], "version": 4&#125;使用快捷键ctrl+shift+p, 键入tasks: configure task, 按Enter打开task.json将以下的内容覆盖到task.json中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// https://code.visualstudio.com/docs/editor/tasks&#123; "version": "2.0.0", "tasks": [ &#123; "label": "Build", // 任务名称, 与launch.json的preLaunchTask相对应 // 如果使用Clang编写C语言, 把command的值改成clang。 // "command": "clang", // 编译c语言 // 如果使用MinGW, 编译C用gcc, 编译c++用g++, 并把-target和-fcolor那两条删去 "command": "clang++", // 要使用的编译器 "args": [ "$&#123;file&#125;", "-o", // 指定输出文件名, 不加该参数则默认输出a.exe, Linux下默认a.out "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe", "-g", // 生成和调试有关的信息 "-Wall", // 开启额外警告 "-static-libgcc", // 静态链接 "-fcolor-diagnostics", // 彩色的错误信息？但貌似clang默认开启而gcc不接受此参数 "--target=x86_64-w64-mingw", // clang的默认target为msvc, 不加这一条就会找不到头文件；Linux下去掉这一条 "-std=c++17" // C语言最新标准为c11, 或根据自己的需要进行修改 ], // 编译命令参数 "windows": &#123; "args": [ "$&#123;file&#125;", "-o", // 指定输出文件名, 不加该参数则默认输出a.exe, Linux下默认a.out "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe", "-g", // 生成和调试有关的信息 "-Wall", // 开启额外警告 "-static-libgcc", // 静态链接 "-fcolor-diagnostics", // 彩色的错误信息？但貌似clang默认开启而gcc不接受此参数 "--target=x86_64-w64-mingw", // clang的默认target为msvc, 不加这一条就会找不到头文件；Linux下去掉这一条 "-std=c++17" // C语言最新标准为c11, 或根据自己的需要进行修改 ] &#125;, "presentation": &#123; "echo": false, "reveal": "always", // 在“终端”中显示编译信息的策略, 可以为always, silent, never。具体参见VSC的文档 "focus": true, // 设为true后可以使执行task时焦点聚集在终端, 但对编译c和c++来说, 设为true没有意义 "panel": "shared" // 不同的文件的编译信息共享一个终端面板 &#125;, "problemMatcher": &#123; "owner": "cpp", "fileLocation": "absolute", "pattern": &#123; "regexp": "^(.*):(\\d+):(\\d+):\\s+(error):\\s+(.*)$", "file": 1, "line": 2, "column": 3, "severity": 4, "message": 5 &#125; &#125; &#125;, &#123; "label": "Run", "type": "shell", "dependsOn": "Build", "command": "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.o", "windows": &#123; "command": "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe" &#125;, "args": [], "presentation": &#123; "reveal": "always", "focus": true &#125;, "problemMatcher": [], "group": &#123; "kind": "test", "isDefault": true &#125; &#125; ]&#125;这个json里写了两个配置, 一个Build, 一个Run。Build 配置：&quot;command&quot; 选编译器用的。写 C++ 就填 clang++ , 写 C 就填 clang&quot;args&quot; 编译参数。像是${fileDirname}和 ${fileBasenameNoExtension}之类的是VS Code的预定义变量, 详见 Variables Reference。&quot;presentation&quot;详见 Tasks - Output behavior 。&quot;reveal&quot; 控制内置终端面板是否跳出到前端。&quot;focus&quot; 焦点是否跳到面板。&quot;echo&quot;控制执行的命令是否输出。&quot;problemMatcher&quot;就 C 语言来说, 功能是将编译器输出的错误捕捉到VS Code的** Problem Panel** 上, 这个面板上的错误并不会及时更新, 每编译一次就更新一次。详见 Tasks - problem-matchers。Run 配置：&quot;dependsOn&quot;先运行哪个任务, 这里就是先运行 Build 任务（先编译后运行）。&quot;group&quot;设置组, 这里设置为默认的test组。详见 Tasks - custom-tasks。键位绑定到窗口左下角点齿轮再点 「键盘快捷方式」设置成alt+f2, 后续就可以使用这个快捷键来运行c/c++代码了¶配置GDB进行调试因为安装了c/c++插件, 所以按f5即可进行调试需配置launch.json使用快捷键ctrl+shift+p, 键入debug: open launch.json, 按Enter打开launch.json将以下的内容覆盖到launch.json中1234567891011121314151617181920212223242526272829303132// https://github.com/Microsoft/vscode-cpptools/blob/master/launch.md&#123; "version": "0.2.0", "configurations": [ &#123; "name": "(gdb) Launch", // 配置名称，将会在启动配置的下拉菜单中显示 "type": "cppdbg", // 配置类型，这里只能为cppdbg "request": "launch", // 请求配置类型，可以为launch（启动）或attach（附加） "program": "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.o", // 将要进行调试的程序的路径 // "program": "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe", "args": [], // 程序调试时传递给程序的命令行参数，一般设为空即可 "stopAtEntry": true, // 设为true时程序将暂停在程序入口处，我一般设置为true "cwd": "$&#123;workspaceFolder&#125;", // 调试程序时的工作目录 "environment": [], //"externalConsole": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 "internalConsoleOptions": "neverOpen", // 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，你应该不需要对gdb手动输命令吧？ "MIMode": "gdb", // 指定连接的调试器，可以为gdb或lldb。但目前lldb在windows下没有预编译好的版本。 "windows": &#123; "program": "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe", "miDebuggerPath": "E:/LLVM/bin/gdb.exe" // 调试器路径，Windows下后缀不能省略 &#125;, "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ], "preLaunchTask": "Build" // 调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应 &#125; ]&#125;配置简要说明：注意&quot;windows&quot;:下的 &quot;miDebuggerPath&quot;。要将其中的路径改为本机的GDB路径, 放在了前文合并后的clang的bin目录下。&quot;preLaunchTask&quot; 运行调试前先运行某个任务，这个Build任务就是前面tasks.josn里的那个。方案二使用code runner(不推荐)缺陷:不能进行调试终端输入会溢出到程序外使用:安装完Code Runner插件后, 在settings.json添加如下的配置:123456789101112131415161718192021222324252627282930313233343536373839404142434445"code-runner.runInTerminal": true,"code-runner.executorMap": &#123; "javascript": "node", "java": "cd $dir &amp;&amp; javac \"$fileName\" &amp;&amp; java \"$fileNameWithoutExt\"", "c": "cd $dir &amp;&amp; clang \"$fileName\" -o \"$fileNameWithoutExt.exe\" -Wall -g -Og -static-libgcc -fcolor-diagnostics --target=x86_64-w64-mingw -std=c11 &amp;&amp; &amp;\"$dir$fileNameWithoutExt\"", "cpp": "cd $dir &amp;&amp; clang++ \"$fileName\" -o \"$fileNameWithoutExt.exe\" -Wall -g -Og -static-libgcc -fcolor-diagnostics --target=x86_64-w64-mingw -std=c++17 &amp;&amp; &amp;\"$dir$fileNameWithoutExt\"", "objective-c": "cd $dir &amp;&amp; gcc -framework Cocoa \"$fileName\" -o $fileNameWithoutExt &amp;&amp; &amp;\"$dir$fileNameWithoutExt\"", "php": "php", "python": "python -u", "perl": "perl", "perl6": "perl6", "ruby": "ruby", "go": "go run", "lua": "lua", "groovy": "groovy", "powershell": "powershell -ExecutionPolicy ByPass -File", "bat": "cmd /c", "shellscript": "bash", "fsharp": "fsi", "csharp": "scriptcs", "vbscript": "cscript //Nologo", "typescript": "ts-node", "coffeescript": "coffee", "scala": "scala", "swift": "swift", "julia": "julia", "crystal": "crystal", "ocaml": "ocaml", "r": "Rscript", "applescript": "osascript", "clojure": "lein exec", "haxe": "haxe --cwd $dirWithoutTrailingSlash --run $fileNameWithoutExt", "rust": "cd $dir &amp;&amp; rustc \"$fileName\" &amp;&amp; &amp;\"$dir$fileNameWithoutExt\"", "racket": "racket", "ahk": "autohotkey", "autoit": "autoit3", "dart": "dart", "pascal": "cd $dir &amp;&amp; fpc \"$fileName\" &amp;&amp; &amp;\"$dir$fileNameWithoutExt\"", "d": "cd $dir &amp;&amp; dmd \"$fileName\" &amp;&amp; &amp;\"$dir$fileNameWithoutExt\"", "haskell": "runhaskell", "nim": "nim compile --verbosity:0 --hints:off --run"&#125;,"code-runner.saveFileBeforeRun": true,"code-runner.preserveFocus": true,"code-runner.ignoreSelection": true然后使用ctrl+alt+n即可运行代码]]></content>
      <categories>
        <category>Vscode</category>
        <category>C/C++配置</category>
      </categories>
      <tags>
        <tag>Vscode</tag>
        <tag>C/C++配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 运行程序的过程]]></title>
    <url>%2Fposts%2F4d1f60ac.html</url>
    <content type="text"><![CDATA[前言Python程序执行时,第一步是将Python程序编译成字节码(字节码是源代码底层的, 与平台无关的表现形式, 实现跨平台的重要特性; 字节码可以提高执行速度, 比起文本文件中的源代码语句, 字节码的运行速度要快得多)。注意, 字节码不是机器的二进制代码(例如, Intel芯片的指令), 字节码是特定于Python的一种表现形式第二步是字节码转发到Python虚拟机(PVM)中运行(类似Java虚拟机(JVM)), PVM就是迭代运行字节码指令的一个大循环, 一个接一个地完成操作 (PVM不是一个独立的程序, 只是Python系统的一部分)。实际上, PVM循环仍需解释字节码Ps: 字节码编译过程是对用户完全隐藏的, 如果Python进程在机器上拥有写入权限, 那么它将把程序的字节码保存为一个以.pyc为扩展名的文件(.pyc表示的是编译过的.py源代码 -&gt; python complied)。如果Python没有写入权限, 程序仍然可以工作, 只是字节码会在内存中生成, 并在程序结束时简单地丢弃。字节码的好处Python保存字节码可以作为一种启动速度的优化如果你在上次保存字节码之后没有修改过源代码, Python将会加载.pyc文件并跳过编译这个步骤。当Python必须重编译时, 它会自动检查源文件和字节码的时间戳, 即当你修改并保存了源代码, 下次程序运行时, 字节码将自动重新创建字节码是源代码底层的, 与平台无关的表现形式, 实现跨平台的重要特性可以隐藏源代码]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode python 自动补全函数时补上括号]]></title>
    <url>%2Fposts%2F15ad0b82.html</url>
    <content type="text"><![CDATA[前言vscode在写python时, 函数能自动补全, 但函数补全后还需要手动加圆括号, 以下可将其设置为自动补上括号安装了Vscode安装了Vscode插件Python使用使用Vscode自动补全python函数时, 发现函数补全后没有圆括号打开Vscode设置, 搜索addbrackets, 然后打上勾即可修改后的效果如图]]></content>
      <categories>
        <category>Vscode</category>
        <category>Python配置</category>
      </categories>
      <tags>
        <tag>Vscode</tag>
        <tag>Vscode Python配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置windows 右键打开cmd]]></title>
    <url>%2Fposts%2Fca153ae0.html</url>
    <content type="text"><![CDATA[windows在文件目录按shift+右键可以打开cmd, 以下通过注册表实现右键打开cmd新建一个普通的文本文档复制如下代码将文档名的后缀改为 .reg双击运行, 允许写入注册表即可效果如图12345678910111213141516Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\background\shell\cmd_here]@="在此处打开命令行""Icon"="cmd.exe"[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\background\shell\cmd_here\command]@="\"C:\\Windows\\System32\\cmd.exe\""[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\cmd_here]@="在此处打开命令行""Icon"="cmd.exe"[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\cmd_here\command]@="\"C:\\Windows\\System32\\cmd.exe\""]]></content>
      <categories>
        <category>Windows</category>
        <category>Cmd</category>
      </categories>
      <tags>
        <tag>Cmd</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 删除所有提交历史并覆盖Github历史]]></title>
    <url>%2Fposts%2Fd69e1361.html</url>
    <content type="text"><![CDATA[概述何时需要删除Git提交的历史记录当历史记录中出现过密码等敏感信息在历史记录中, 需要删除历史记录时当项目因历史记录过多, 导致历史记录占用了大量内存时, 比如Github仓库个人总容量时1GB不够用时当你想要一个全新的项目的时候, 并且想保持项目代码不变Git命令1234567891011121314151617# 1. 创建全新的孤立分支 latest_branchgit checkout --orphan latest_branch# 2. 暂存所有文件git add -A# 3. 提交所有文件的修改到latest_branchgit commit -am "del all history"# 4. 删除原来的master分支git branch -D master# 5. 修改latest_branch分支名为mastergit branch -m master# 6. 强制更新远程服务器的master分支, 至此清空git所有历史git push -f origin master不带注释, 方便复制版123456git checkout --orphan latest_branchgit add -Agit commit -am "del all history"git branch -D mastergit branch -m mastergit push -f origin master]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next leancloud文章阅读次数配置以及插件无效问题解决]]></title>
    <url>%2Fposts%2F74d5335f.html</url>
    <content type="text"><![CDATA[前言由于Next主题修复了leancloud的安全问题, 导致以前leancloud失效, 所以重新介绍如何配置leancloud所有使用该插件而未经修复的NexT站点或使用类似方法集成Leancloud访客统计功能的站点都被认为是不安全的，请尽快修复效果如图注册Leancloud并创建应用首先，前往Leancloud官网leancloud.cn进行注册，并登陆。点击创建应用输入应用的名称(随便起都行), 选择开发版, 点击创建创建成功后点击右上角的设置小齿轮点击存储-创建Class-Class名称设置为Counter(必须为Counter)-选择无限制-点击创建创建后点击设置-点击应用Key-获取App ID和App Key将获取到的App ID和App Key设置到Next主题配置文件_config.yml配置文件已存在这个配置, 只要把id和key加上去就好了1234leancloud_visitors: enable: true app_id: &lt;&lt;your app id&gt;&gt; app_key: &lt;&lt;your app key&gt;&gt;点击安全中心, 填写自己博客对应的域名（注意协议、域名和端口号需严格一致）点击云引擎-点击部署-点击在线编辑点击创建函数-选择Hook-AV.Cloud.选择beforeSave-类选择Counter-添加代码-点击保存12345678var query = new AV.Query("Counter");if (request.object.updatedKeys.indexOf('time') !== -1) &#123; return query.get(request.object.id).then(function (obj) &#123; if (obj.get("time") + 1 !== request.object.get("time")) &#123; throw new AV.Cloud.Error('Invalid update!'); &#125; &#125;)&#125;点击部署待出现红框处的成功部署信息后，点击关闭设置权限打开Next主题配置文件_config.yml, 将leancloud_visitors下的security设置为true（如没有则新增）1234567891011leancloud_visitors: enable: true app_id: &lt;&lt;your app id&gt;&gt; # 同前文的id app_key: &lt;&lt;your app key&gt;&gt; # 同前文的key # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security security: true # 由于Leancloud免费版的云引擎存在请求线程数和运行时间限制以及休眠机制， # 很多时候访客数量加载会很慢。 # 如果设置betterPerformance为true， # 则网页则会在提交请求之前直接显示访客人数为查询到的人数+1，以增加用户体验。 betterPerformance: false打开站点配置文件_config.yml123456leancloud_counter_security: enable_sync: true app_id: &lt;&lt;your app id&gt;&gt; # 同前文的id app_key: &lt;&lt;your app key&gt;&gt; # 同前文的key username: password:打开命令行cmd并进入站点文件夹，键入以下命令以安装hexo-leancloud-counter-security插件1npm install hexo-leancloud-counter-security --save接着键入命令1hexo lc-counter register &lt;&lt;username&gt;&gt; &lt;&lt;password&gt;&gt;PS: 将&lt;&lt;username&gt;&gt;和&lt;&lt;password&gt;&gt;替换为你自己的用户名和密码（不必与leancloud的账号）相同。此用户名和密码将在hexo部署时使用。打开站点配置文件_config.yml, 将&lt;&lt;username&gt;&gt;和&lt;&lt;password&gt;&gt;替换为你刚刚设置的用户名和密码123456leancloud_counter_security: enable_sync: true app_id: &lt;&lt;your app id&gt;&gt; # 同前文的id app_key: &lt;&lt;your app key&gt;&gt; # 同前文的key username: &lt;&lt;username&gt;&gt; #如留空则将在部署时询问 password: &lt;&lt;password&gt;&gt; #建议留空以保证安全性，如留空则将在部署时询问返回Leancloud控制台的应用内, 检查_User表中是否出现一条记录（图示以用户名为admin为例）进入Counter表, 打开权限设置至此配置完成]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 博客添加版权]]></title>
    <url>%2Fposts%2F54c43f8b.html</url>
    <content type="text"><![CDATA[效果如图:实现打开主题文件themes/next/layout/_macro/post.swig找到&lt;footer class=&quot;post-footer&quot;&gt; 标签, 在其代码替换成如下的代码要被替换的代码12345678&lt;footer class=&quot;post-footer&quot;&gt; &#123;% if post.tags and post.tags.length and not is_index %&#125; &lt;div class=&quot;post-tags&quot;&gt; &#123;% for tag in post.tags %&#125; &lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;% endif %&#125;替换后的代码123456789101112131415161718192021222324252627282930313233343536373839&lt;footer class=&quot;post-footer&quot;&gt;&#123;% if post.tags and post.tags.length and not is_index %&#125; &#123;# 版权声明节点 #&#125; &lt;div&gt; &#123;% if not is_index %&#125; &lt;ul class=&quot;post-copyright&quot;&gt; &lt;li class=&quot;post-copyright-link&quot;&gt; &lt;strong&gt;本文作者：&lt;/strong&gt; &lt;a href=&quot;/&quot; title=&quot;欢迎访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;post-copyright-link&quot;&gt; &lt;strong&gt;本文标题：&lt;/strong&gt; &lt;a href=&quot;&#123;&#123; url_for(post.permalink) &#125;&#125;&quot; title=&quot;&#123;&#123; post.title &#125;&#125;&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;post-copyright-link&quot;&gt; &lt;strong&gt;本文链接：&lt;/strong&gt; &lt;a href=&quot;&#123;&#123; url_for(post.permalink) &#125;&#125;&quot; title=&quot;&#123;&#123; post.title &#125;&#125;&quot;&gt;&#123;&#123; post.permalink &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;post-copyright-date&quot;&gt; &lt;strong&gt;发布时间： &lt;/strong&gt;&#123;&#123; post.date.format(&quot;YYYY年M月D日 - HH时MM分&quot;) &#125;&#125; &lt;/li&gt; &lt;li class=&quot;post-copyright-license&quot;&gt; &lt;strong&gt;版权声明： &lt;/strong&gt; 本文由 &#123;&#123;theme.author&#125;&#125; 原创。 &lt;/li&gt; &lt;/ul&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;# 这里是将标签的井字符号替换成图标 #&#125; &lt;div class=&quot;post-tags&quot;&gt; &#123;% for tag in post.tags %&#125; &lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;% endif %&#125;]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 添加背景图片并自适应]]></title>
    <url>%2Fposts%2Fc08e78b.html</url>
    <content type="text"><![CDATA[在站点配置文件夹source/images/放入你的背景图片然后修改主题文件夹themes/source/css/_custom/custom.stylPS: 这个文件是存放用户自定义css样式的在custom.styl开头加入如下的代码12345678910111213141516body &#123; background:url(/images/background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size: cover; -webkit-background-size: cover; -o-background-size: cover; -moz-background-size: cover; -ms-background-size: cover; /*这是设置底部文字, 看个人需要修改*/ #footer &gt; div &gt; div &#123; color:#eee; &#125;&#125;]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 添加萌萌的宠物live2d]]></title>
    <url>%2Fposts%2Ffbd1f97f.html</url>
    <content type="text"><![CDATA[概述添加萌宠来装饰Hexo站点, 使用到的插件hexo-helper-live2d添加萌宠安装插件命令行cmd进入站点文件夹12cd .\TestBlog\npm install hexo-helper-live2d --save下载完插件后, 使用hexo s启动服务器发现左下角已经有live2d模型了在站点配置文件_config.yml中添加配置配置信息可以设置live2d的位置、大小、透明度等更多配置信息可看Github hexo-helper-live2d上的介绍12345678910111213141516171819live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: # 这是白猫的模型 use: live2d-widget-model-tororo display: # 设置模型的位置 position: right width: 120 height: 240 mobile: show: false react: opacityDefault: 1 opacityOnHover: 1下载你喜欢的模型命令行cmd进入站点文件夹, 使用npm install {your model's package name}下载你喜欢的模型模型列表12345678910111213141516171819202122live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16[模型预览](https://huaji8.top/post/live2d-plugin-2.0/)效果如图比如下载tororo npm install live2d-widget-model-tororo完成上述的配置]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next访客统计不蒜子]]></title>
    <url>%2Fposts%2Fa2e026ef.html</url>
    <content type="text"><![CDATA[Hexo增加访客统计效果如图Next 主题在版本6.0以上已经内置了不蒜子访客统计的代码,只要修改主题配置文件_config.yml即可123456789101112# Show Views/Visitors of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzibusuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye # 文章的阅读次数不用不蒜子 # 因为在首页看不到阅读数，要进入文章才能看到 post_views: false post_views_icon: eye文章阅读次数设置]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next主题配置]]></title>
    <url>%2Fposts%2F4259465c.html</url>
    <content type="text"><![CDATA[概述 看懂配置文件， 自己想怎么弄就怎么弄！！Next 版本号6.0.0以上主要根据Next 主题配置文件进行部分介绍¶设置菜单使用Next主题， 需手动创建 tags页面和categories页面 (创建页面都是如下的操作)命令行cmd进入站点文件夹123cd ./TestBloghexo new page &quot;tags&quot;hexo new page &quot;categories&quot;进入站点文件夹下的source文件夹, 可以看到 Hexo给我们创建了两个文件夹，categories和tagsPS: Hexo创建一个新的页面就会在站点文件夹下的source文件夹新建该页面的文件夹修改 categories文件夹下的index.md为如下12345---title: 分类date: 2018-11-08 20:41:49type: &quot;categories&quot;---修改tags文件夹下的index.md为如下12345---title: 标签date: 2018-11-08 20:41:30type: &quot;tags&quot;---修改主题配置文件_config.yml修改了主题配置文件中menu的话，就会将分类categories和标签tags页面的超链接显示到菜单栏上123456789menu: home: / || home categories: /categories/ || th tags: /tags/ || tags # about: /about/ || user archives: /archives/ || archive # schedule: /schedule/ || calendar # sitemap: /sitemap.xml || sitemap # commonweal: /404/ || heartbeatPS: menu配置的解释比如categories: /path/ || th表示菜单栏显示的名字为categories, 资源放在站点文件夹的 source/path/下, th表示FrontAwesome的th图标关于菜单栏显示 categories为中文, 是因为站点配置文件设置了语言为中文, 然后hexo会去找英文转中文的配置, 该配置在themes/next/languages/zh-CN.yml¶修改Next主题的样式Next主题有4种样式可以切换12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: GeminiMuseMistPiscesGemini¶在侧边栏上加入Github CSDN等信息修改social字段即可, 网址后面的是图标, 到FrontAwesome找到自己喜欢的图标即可使用123456789101112131415161718social: GitHub: https://github.com/vonsdite || github CSDN: https://blog.csdn.net/vonsdite || bug E-Mail: mailto:vonsdite@gmail.com || envelope #Weibo: https://weibo.com/yourname || weibo #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skypesocial_icons: enable: true icons_only: false transition: false¶网站右上角加Github标识在网站的右上角加入Github Follow的标识12345# Follow me on GitHub banner in right-top corner.# Usage: `permalink || title`# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the title and aria-label name.github_banner: https://github.com/vonsdite || Follow me on GitHub¶修改Next的用户头像在站点文件夹source/images/放入你的头像图片修改配置文件如图123456789101112131415# Sidebar Avataravatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.png # If true, the avatar would be dispalyed in circle. # 圆形框 rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. # 透明度 0 - 1 间设置 opacity: 1 # If true, the avatar would be rotated with the cursor. # 设置为真, 表示头像会转 rotated: false¶设置查看文章时有无TOC如果想关闭TOC前的数字, 就将number设置为false即可123456789# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false¶设置Sidebar以下的配置信息是设置Sidebar的位置, 和Sidebar的显示, 不同的Next主题有不同的设置, 具体见配置信息1234567891011121314151617181920212223242526272829303132sidebar: # Sidebar Position, available value: left | right (only for Pisces | Gemini). position: left #position: right # Manual define the sidebar width. # If commented, will be default for: # Muse | Mist: 320 # Pisces | Gemini: 240 #width: 300 # Sidebar Display, available value (only for Muse | Mist): # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle. display: post #display: always #display: hide #display: remove # Sidebar offset from top menubar in pixels (only for Pisces | Gemini). offset: 12 # Back to top in sidebar (only for Pisces | Gemini). b2t: false # Scroll percent label in b2t button. scrollpercent: true # Enable sidebar on narrow view (only for Muse | Mist). onmobile: false¶文章设置¶设置点击阅读全文时文章是否跳到阅读全文位置12# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: false¶保存上次阅读的位置在cookies中12# Automatically saving scroll position on each post/page in cookies.save_scroll: false¶设置阅读全文按钮建议不要自动生成阅读全文, 建议使用在你的文章中使用&lt;!-- more --&gt;来生成阅读全文按钮123456789# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150# Read more button# If true, the read more button would be displayed in excerpt sectionread_more_btn: true¶在文章加入打赏在站点文件夹source/images/放入支付宝和微信收款码二维码, 修改配置即可123456reward: enable: true #comment: Donate comment here wechatpay: /images/wechatpay.jpg alipay: /images/alipay.jpg #bitcoin: /images/bitcoin.png¶设置文章字体1234567# To avoid space between header and sidebar in Pisces / Gemini themes # recommended to use Web Safe fonts for `global` (and `logo`):# Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia # | Palatino | Garamond | Comic Sans MS | Trebuchet MS posts: external: true family: Comic Sans MS¶修改网站的图标效果如图准备一张图片，然后到图片网站制作16*16, 32*32大小的图标将制作好的图标放入到站点文件夹source/images中修改Next主题配置文件修改配置文件中favicon的值, 路径为你保存好的图标路径名1234567favicon: small: /images/favicon-16x16-next.ico medium: /images/favicon-32x32-next.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml¶设置网站底部信息修改网站部署的起始年份 since修改网站底部的图标 icon为爱心, 并设置图标颜色, 并让图标动起来（有心跳的感觉）1234567891011121314footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2018 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons # `heart` is recommended with animation in red (#ff0000). name: heart # If you want to animate the icon, set it to true. animated: true # Change the color of icon, using Hex Code. color: "#ff0000"关闭网站底部 Hexo驱动和Next主题版本123456789101112# 该值属于 footer键的一部分 powered: # Hexo link (Powered by Hexo). enable: false # Version info of Hexo after Hexo link (vX.X.X). version: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false¶使用Hexo data files 配置主题不一定采用，看个人需要为了使主题与配置分离, 方便升级主题，采用 Hexo data files 进行配置创建文件在站点文件夹创建source/_data/next.yml文件复制配置文件将所有配置内容，包括站点和主题配置文件移入 source/_data/next.yml 文件。后面的所有配置更改都将在此文件内进行。next.yml 文件中启用 override1override: true]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 增加字数统计和阅读时长]]></title>
    <url>%2Fposts%2Fbff1f160.html</url>
    <content type="text"><![CDATA[添加字数统计和阅读时长效果如图¶安装插件1npm install hexo-symbols-count-time --save¶修改配置文件在博客根目录下的站点配置文件_config.yml配置文件最后加入如下代码1234567symbols_count_time: #文章内是否显示 symbols: true time: true # 网页底部是否显示 total_symbols: true total_time: true修改主题配置文件_config.yml配置文件中的symbols_count_time的值(用ctrl + F来找到这个键)123456789101112# Post wordcount display settings# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: separated_meta: true #文章中的显示是否显示文字（本文字数|阅读时长） item_text_post: true #网页底部的显示是否显示文字（站点总字数|站点阅读时长） item_text_total: false # Average Word Length (chars count in word) awl: 4 # Words Per Minute wpm: 275]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 站点配置文件_config详解]]></title>
    <url>%2Fposts%2Fe990fc02.html</url>
    <content type="text"><![CDATA[概述 看懂配置文件， 自己想怎么弄就怎么弄！！Hexo 站点配置文件参数介绍来自官网本文除了搬运官网中文外， 还会翻译 英文官网内容， 同时加上自己的见解常用配置项配置项名描述Site站点信息配置， 最开始需要修改Url主要修改里面的站点网址deploy部署的配置¶Site参数描述title网站标题subtitle网站副标题description网站描述author您的名字language网站使用的语言，Next主题中文为zh-CNtimezone网站时区。Hexo 默认使用您电脑的时区。查看时区列表。比如说：Asia/Shanghai、UTC其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词author参数用于主题显示文章的作者¶Url参数描述默认值url网址root网站根目录permalink文章的 永久链接 格式:year/:month/:day/:title/permalink_defaults永久链接中各部分的默认值如果您的网站存放在子目录中,例如 http://yoursite.com/blog ,则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/PS： 永久链接默认格式的 层级太深，修改永久链接的方法 -&gt; Hexo 修改永久链接的默认格式¶Directory参数描述默认值source_dir资源文件夹，这个文件夹用来存放内容。sourcepublic_dir公共文件夹，这个文件夹用于存放生成的站点文件。publictag_dir标签文件夹tagsarchive_dir归档文件夹archivescategory_dir分类文件夹categoriescode_dirInclude code 文件夹downloads/codei18n_dir国际化（i18n）文件夹:langskip_render跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。比如说想跳过MyPage目录下所有文件的渲染，可使用skip_render: mypage/**/*, 这样会原样输出source/mypage/，而不修改它¶Writing参数描述默认值new_post_name新文章的文件名称:title.mddefault_layout预设布局postauto_spacing在中文和英文之间加入空格falsetitlecase把标题转换为 title casefalseexternal_link在新标签中打开链接truefilename_case把文件名称转换为 (1) 小写或 (2) 大写0render_drafts显示草稿falsepost_asset_folder启动 Asset 文件夹falserelative_link把链接改为与根目录的相对位址falsefuture显示未来的文章truehighlight代码块的设置¶Home page setting这里的参数是设置首页的，一般不动它参数描述默认值index_generator网站首页生成器， 有path, per_page, order_by参数path博客首页所在的路径''per_page一页显示的文章数，默认为10，即一页显示10篇文章。设置为0时表示禁止分页10order_by文章的排序方式，默认按时间降序-date¶Category &amp; Tag参数描述默认值default_category默认分类uncategorizedcategory_map分类别名tag_map标签别名¶Date / Time formatHexo 使用 Moment.js 来解析和显示时间。参数描述默认值date_format日期格式YYYY-MM-DDtime_format时间格式H:mm:ss¶Pagination参数描述默认值per_page每页显示的文章量 (0 = 关闭分页功能)10pagination_dir分页目录page¶Extensions参数描述theme当前主题名称。值为false时禁用主题deploy部署的设置，可以部署git、leancloud等，见deploy例子¶deploy1234567# 设置多个的话，用-type来设置deploy:- type: git repo: git@github.com:UserName/UserName.github.io.git branch: master- type: leancloud_counter_security_sync¶Include/Exclude Files/Folders在配置文件中，设置include / exclude以使hexo显式处理或忽略某些文件/文件夹。参数描述includeHexo默认忽略的隐藏文件和文件夹，可设置此字段将使Hexo处理它们exclude设置 Hexo 忽略的文件列表¶Sample12345# Include/Exclude Files/Foldersinclude: - .nojekyllexclude: - .DS_Store]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 修改超链接的样式]]></title>
    <url>%2Fposts%2F13afd8d4.html</url>
    <content type="text"><![CDATA[¶Hexo Next 默认超链接样式默认的Next主题的超链接的样式是 单纯的黑色 + 下划线显得有点单调且不显眼¶修改超链接样式打开博客目录下./themes/source/css/_custom/custom.styl在cutom.styl 最开始处加入如下的代码12345678910if hexo-config("custom_css.post_body_a.enable") .post-body a:not(.btn)&#123; color: convert(hexo-config("custom_css.post_body_a.normal_color")); border-bottom: none; &amp;:hover &#123; color: convert(hexo-config("custom_css.post_body_a.hover_color")); text-decoration: underline; &#125; &#125;PS: 其中的 a:not(.btn) 是为了不影响阅读全文按钮然后在主题配置文件./themes/_config.yml中加入custom_css的配置123456custom_css: # the style of post body link post_body_a: enable: true normal_color: "#0593d3" hover_color: "#0477ab"后续修改超链接样式时，只需修改配置文件里面的颜色值即可]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 修改永久链接的默认格式]]></title>
    <url>%2Fposts%2F96723aac.html</url>
    <content type="text"><![CDATA[Hexo 永久链接Hexo的永久链接的默认格式是 :year/:month/:day/:title/永久链接的意思，即访问站点下某一篇文章时，其路径是 2018/11/17/xxxx/，而且它保存在本地站点的public目录也是2018/11/17/xxxx/坏处：如果我们的文章标题是中文的，那么该路径就会出现中文字符在路径中出现了中文字符很容易引发各种问题不利于seo，因为路径包含了年月日三个层级，层级太深不利于百度蜘蛛抓取使用 hexo-abbrlink解决办法利用其它的插件来生成唯一的路径，这样就算我们的文件标题随意修改，也不会导致原本的链接失效而造成站点下存在大量的死链。¶安装插件1npm install hexo-abbrlink --save¶修改站点配置文件打开根目录下的_config.yml文件，修改permalink, 如下:123456# permalink: :year/:month/:day/:title/# permalink_defaults:permalink: posts/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex¶完成完成上述步骤后运行如下操作123hexo clean # 删除缓存hexo g # 生成静态文件hexo s # 启动服务器]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Next搭建博客 (三) 使用Next主题]]></title>
    <url>%2Fposts%2Fbcc7a049.html</url>
    <content type="text"><![CDATA[安装 NexTHexo安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改配置文件即可。在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。¶下载主题在终端窗口cmd下，定位到 Hexo 站点目录下。12cd your-hexo-sitegit clone git@github.com:theme-next/hexo-theme-next.git themes/next¶启用主题与所有 Hexo 主题启用的模式一样。 当 主题下载完成 后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。1theme: next到此，NexT 主题安装完成。PS: 在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。¶后续接下来可以根据配置来配置自己的博客了！！Hexo 站点配置文件_config详解Hexo Next主题配置]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Next搭建博客 (二) Hexo命令]]></title>
    <url>%2Fposts%2F25b4113e.html</url>
    <content type="text"><![CDATA[Hexo 常用命令一般只用到如下表的命令其他命令可以查看本文下方Hexo 命令 或者查看 https://hexo.io/docs/commands.html常用命令描述init新建一个网站(hexo init &lt;FolderName&gt;)new新建一篇文章(hexo new post &lt;PostName&gt;)、新建一篇草稿(hexo new draft &lt;DraftName&gt; )、新建一个页面(hexo new page &lt;PageName&gt;)clean清除缓存文件 (db.json) 和已生成的静态文件 (public) (使用hexo clean)generate生成静态文件(hexo g)deploy部署网站(hexo d), 常与generate命令一起用(hexo g -d 或者 hexo d -g)server启动服务器(hexo s or hexo server)help帮助命令(hexo help or hexo help [command name])TOCHexo 命令initnewgeneratepublishserverdeployrendermigratecleanhelplistversion选项安全模式调试模式简洁模式自定义配置文件的路径显示草稿自定义 CWDHexo 命令¶init1hexo init [folder]新建一个网站。如果没有设置 folder, Hexo 默认在目前的文件夹建立网站(当前文件夹必须为空)。¶new1hexo new [layout] &lt;title&gt;新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。layout是根目录下的scaffolds的模板，默认是post.md模板。 layout关键字都可以用scaffolds下的模板名来代替¶generate1hexo generate生成静态文件选项描述-d, --deploy文件生成后立即部署网站-w, --watch监视文件变动该命令可以简写为1hexo g¶publish用得少1hexo publish [layout] &lt;filename&gt;发表草稿¶server1hexo server启动服务器默认情况下，访问网址为： http://localhost:4000/选项描述-p, --port重设端口-s, --static只使用静态文件-l, --log启动日记记录，使用覆盖记录格式¶deploy1hexo deploy部署网站参数描述-g, --generate部署之前预先生成静态文件该命令可以简写为：1hexo d¶render用得少1hexo render &lt;file1&gt; [file2] ...渲染文件参数描述-o, --output设置输出路径¶migrate用得少1hexo migrate &lt;type&gt;从其他博客系统 迁移内容¶clean1hexo clean清除缓存文件 (db.json) 和已生成的静态文件 (public)在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。¶help12345# 查看hexo所有命令及功能hexo help # 查看命令的使用方法 hexo help [command]Hexo帮助命令可以查看Hexo的命令及其用法也可以查看Hexo命令的具体使用和命令搭配的选项¶list用得少1hexo list &lt;type&gt;列出网站资料¶version用得少1hexo version显示 Hexo 版本¶选项¶安全模式1hexo --safe在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。¶调试模式1hexo --debug在终端中显示调试信息并记录到debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。¶简洁模式1hexo --silent隐藏终端信息。¶自定义配置文件的路径1hexo --config custom.yml自定义配置文件的路径，执行后将不再使用 _config.yml。¶显示草稿1hexo --draft显示 source/_drafts 文件夹中的草稿文章。¶自定义 CWD1hexo --cwd /path/to/cwd自定义当前工作目录（Current working directory）的路径。]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Next搭建博客 (一) 安装使用Hexo]]></title>
    <url>%2Fposts%2F2276cdd3.html</url>
    <content type="text"><![CDATA[概述本文为搭建博客的第一部分，本文内容主要如下:介绍hexo安装hexo使用hexo生成初步的博客(Next为hexo的主题，后续才会说明到)(文章内容都是以Windows为例，其他操作系统相似)¶什么是HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。PS: Hexo的具体介绍、文档均可在官网中查找 Hexo官网¶安装Hexo¶安装Hexo前需要安装Git -&gt; 点我下载Node.js -&gt; 点我下载¶完成上一步后打开命令提示符键入命令即可完成Hexo的安装解释： 安装Node.js过程中，已经将Node.js的安装目录加到环境变量中，所以可以使用npm命令。1npm install -g hexo-cli¶建站安装 Hexo完成后，使用 cmd 执行下列命令， Hexo将会在指定文件夹中新建所需要的文件。123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install新建完成后，指定文件夹的目录如下：1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themesauto此时已经建站完成了, 只要执行命令即可运行博客网站1hexo s¶文件介绍_config.yml网站的 配置 信息，您可以在此配置大部分的参数。package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。1234567891011121314151617181920package.json&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.0.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.0&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.0&quot;, &quot;hexo-generator-index&quot;: &quot;^0.1.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.1.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.1.0&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.2.4&quot;, &quot;hexo-server&quot;: &quot;^0.1.2&quot; &#125;&#125;scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线) 的文件 / 文件夹和隐藏的文件将会被忽略 。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。themes主题 文件夹。Hexo会根据主题来生成静态页面。]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
</search>
